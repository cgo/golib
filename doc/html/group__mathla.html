<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>golib: Linear Algebra</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">golib&#160;<span id="projectnumber">0.5</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__mathla.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Linear Algebra</div>  </div>
<div class="ingroups"><a class="el" href="group__math.html">Mathematics and numerics</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1Eigenvalue.html">goMath::Eigenvalue&lt; Real &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgoMath_1_1Eigenvalue.html" title="Eigenvalue computation of real matrices.">Eigenvalue</a> computation of real matrices.  <a href="classgoMath_1_1Eigenvalue.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1LU.html">goMath::LU&lt; Real &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgoMath_1_1LU.html" title="LU Decomposition.">LU</a> Decomposition.  <a href="classgoMath_1_1LU.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">Matrix</a> class.  <a href="classgoMath_1_1Matrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1VectorIterator.html">goMath::VectorIterator&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">Vector</a> iterator for multi-dimensional array data.  <a href="classgoMath_1_1VectorIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1ConstVectorIterator.html">goMath::ConstVectorIterator&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cons iterator over vectors.  <a href="classgoMath_1_1ConstVectorIterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1SVD.html">goMath::SVD&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular value decomposition. This class can do full <a class="el" href="classgoMath_1_1SVD.html" title="Singular value decomposition. This class can do full SVD or thin SVD. It uses sgesvd_() or dgesvd_() ...">SVD</a> or thin <a class="el" href="classgoMath_1_1SVD.html" title="Singular value decomposition. This class can do full SVD or thin SVD. It uses sgesvd_() or dgesvd_() ...">SVD</a>. It uses sgesvd_() or dgesvd_() from the linked LAPACK library (as opposed to <a class="el" href="classgoMath_1_1ThinSVD.html">goMath::ThinSVD</a>). Instantiated for goFloat and goDouble types.  <a href="classgoMath_1_1SVD.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1Vector.html">goMath::Vector&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">General vector class.  <a href="classgoMath_1_1Vector.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga11b4124839e8b90f4d1120384792b88f"></a><!-- doxytag: member="mathla::Matrixd" ref="ga11b4124839e8b90f4d1120384792b88f" args="" -->
typedef <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; goDouble &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>goMath::Matrixd</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b9c9655fdce92a0fd3a339e17b2dba5"></a><!-- doxytag: member="mathla::Matrixf" ref="ga4b9c9655fdce92a0fd3a339e17b2dba5" args="" -->
typedef <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; goFloat &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>goMath::Matrixf</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae0c54054eaf314aca2551a678421ddd7"></a><!-- doxytag: member="mathla::Vectorf" ref="gae0c54054eaf314aca2551a678421ddd7" args="" -->
typedef <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; goFloat &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>goMath::Vectorf</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac0a386a36ed32e424ed0202e7368740a"></a><!-- doxytag: member="mathla::Vectord" ref="gac0a386a36ed32e424ed0202e7368740a" args="" -->
typedef <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; goDouble &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>goMath::Vectord</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga87a2ca877839e64e221827ad1a8e6b1e"></a><!-- doxytag: member="mathla::Vectori" ref="ga87a2ca877839e64e221827ad1a8e6b1e" args="" -->
typedef <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; goInt32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>goMath::Vectori</b></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaadd1b5523cbdeaaf0125edbda04951b0"></a><!-- doxytag: member="mathla::complexEigenvaluesHermite" ref="gaadd1b5523cbdeaaf0125edbda04951b0" args="(const goMath::Matrix&lt; goComplexf &gt; &amp;m, goMath::Vectorf &amp;eigenvaluesRet, goFixedArray&lt; goMath::Vector&lt; goComplexf &gt; &gt; *eigenvectorsRet=0)" -->
<a class="el" href="gotypes_8h.html#a02284d9088a729cca83dc808dd409e09">goSize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>goMath::complexEigenvaluesHermite</b> (const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; <a class="el" href="classgoComplex.html">goComplexf</a> &gt; &amp;m, <a class="el" href="classgoMath_1_1Vector.html">goMath::Vectorf</a> &amp;eigenvaluesRet, <a class="el" href="classgoFixedArray.html">goFixedArray</a>&lt; <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="classgoComplex.html">goComplexf</a> &gt; &gt; *eigenvectorsRet=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mathla.html#ga1a20bf18bfad14416d95c940492202d4">goMath::matrixMult</a> (T alpha, const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;A, bool transA, const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;B, bool transB, T beta, <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate <img class="formulaInl" alt="$C = \alpha \cdot A \cdot B + \beta \cdot C $" src="form_25.png"/>.  <a href="#ga1a20bf18bfad14416d95c940492202d4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gab5e561b75ed103eaa59088ed88ade5dd"></a><!-- doxytag: member="mathla::matrixPower" ref="gab5e561b75ed103eaa59088ed88ade5dd" args="(goMath::Matrix&lt; T &gt; &amp;A, T scalar)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>goMath::matrixPower</b> (<a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;A, T scalar)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mathla.html#ga6976b4170ff78b845a56bd9be509d34b">goMath::matrixVectorMult</a> (T alpha, const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;A, bool transA, const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;x, T beta, <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate <img class="formulaInl" alt="$ y = \alpha A x + \beta y $" src="form_26.png"/>.  <a href="#ga6976b4170ff78b845a56bd9be509d34b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mathla.html#gab09c61d1d33f52541fc92d5d4d02c10a">goMath::vectorAdd</a> (T alpha, const Vector&lt; T &gt; &amp;x, Vector&lt; T &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">y = alpha * x + y  <a href="#gab09c61d1d33f52541fc92d5d4d02c10a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mathla.html#ga6b1c345b0afa0ce9ed0a40a9e61085d0">goMath::vectorOuter</a> (T alpha, const Vector&lt; T &gt; &amp;x, const Vector&lt; T &gt; &amp;y, <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;ret)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Outer vector product <img class="formulaInl" alt="$ A = A + \alpha \cdot x \cdot y^\top $" src="form_56.png"/>.  <a href="#ga6b1c345b0afa0ce9ed0a40a9e61085d0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class matrix_type , class pivot_vector &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mathla.html#gaef0fe84b124840f509bdd66c8eb39464">goMath::Lapack::getrf</a> (matrix_type &amp;A, pivot_vector &amp;ipiv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lapack getrf.  <a href="#gaef0fe84b124840f509bdd66c8eb39464"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class matrix_type , class pivot_vector &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mathla.html#gae345db3ca8faa550f002a0bc22cd72a4">goMath::Lapack::getrs</a> (const matrix_type &amp;A, bool transA, matrix_type &amp;B, const pivot_vector &amp;ipiv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lapack getrs.  <a href="#gae345db3ca8faa550f002a0bc22cd72a4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf8ff680e4fce85e8254e9126ffd76a6c"></a><!-- doxytag: member="mathla::getrs" ref="gaf8ff680e4fce85e8254e9126ffd76a6c" args="(const matrix_type &amp;A, bool transA, goMath::Vector&lt; typename matrix_type::value_type &gt; &amp;B, const pivot_vector &amp;ipiv)" -->
template&lt;class matrix_type , class pivot_vector &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>goMath::Lapack::getrs</b> (const matrix_type &amp;A, bool transA, <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; typename matrix_type::value_type &gt; &amp;B, const pivot_vector &amp;ipiv)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class matrix_type , class pivot_vector &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mathla.html#gaec7ce00d0fcba96cab92198340330b6b">goMath::Lapack::getri</a> (matrix_type &amp;A, const pivot_vector &amp;ipiv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lapack getri, invert a LU-decomposed matrix.  <a href="#gaec7ce00d0fcba96cab92198340330b6b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class matrix_type , class vector_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mathla.html#ga7340c6fb5480a7d3d81d2b1d1a00faad">goMath::Lapack::gels</a> (matrix_type &amp;A, bool transA, vector_type &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lapack gels. Least square solution of a linear system.  <a href="#ga7340c6fb5480a7d3d81d2b1d1a00faad"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class matrix_type , class vector_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mathla.html#gad9bce46639a52486fbc3075e53dc094e">goMath::Lapack::gelss</a> (matrix_type &amp;A, bool transA, vector_type &amp;b, vector_type *singularValues=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lapack gelss.  <a href="#gad9bce46639a52486fbc3075e53dc094e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class matrix_type , class vector_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mathla.html#ga644670c32dd181c83c5f0e6f060e68dc">goMath::Lapack::posv</a> (matrix_type &amp;A, vector_type &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lapack *posv procedure for solving symmetric linear systems.  <a href="#ga644670c32dd181c83c5f0e6f060e68dc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class matrix_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mathla.html#ga2182f8f21e6e07038ffc5126d0c99a3f">goMath::Lapack::posv</a> (matrix_type &amp;A, matrix_type &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lapack *posv procedure for solving symmetric linear systems.  <a href="#ga2182f8f21e6e07038ffc5126d0c99a3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa6b4f481485fba0aded1d3e4e9c24529"></a><!-- doxytag: member="mathla::conjInnerProduct" ref="gaa6b4f481485fba0aded1d3e4e9c24529" args="(const Vector&lt; T &gt; &amp;) const " -->
T&#160;</td><td class="memItemRight" valign="bottom"><b>goMath::Vector::conjInnerProduct</b> (const Vector&lt; T &gt; &amp;) const </td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<h2><a class="anchor" id="math-las"></a>
Linear Algebra Objects</h2>
<p>Use goMatrix and goVector for matrix and vector operations. Others, like <a class="el" href="classgo4Vector.html">go4Vector</a> and such will be deprecated and replaced solely by the former two classes. goMatrix and goVector use CBLAS routines for some operations and more will be added. Using CBLAS moves the matter of optimisation for a specific platform outside of golib. The operator* and operator*= operators use CBLAS. For best performance, when you want to do something like C = A^  B + C, use goMatrixMult(). Explicitly transposing a matrix should not be necessary, if I find it is for some operation, I will add functions that overcome this. Transposition of a goMatrix is possible with getTranspose() or transpose(), but is very slow since the data are copied.</p>
<p>Singular value decomposition can be done using goSVD. Eigenvalues and eigenvectors can be calculated with goEigenvalue. Both are adapted versions from the Template Numerical Toolkit, a freely available implementation of a few linear algebra algorithms. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga7340c6fb5480a7d3d81d2b1d1a00faad"></a><!-- doxytag: member="goMath::Lapack::gels" ref="ga7340c6fb5480a7d3d81d2b1d1a00faad" args="(matrix_type &amp;A, bool transA, vector_type &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class matrix_type , class vector_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::Lapack::gels </td>
          <td>(</td>
          <td class="paramtype">matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lapack gels. Least square solution of a linear system. </p>
<p>For <img class="formulaInl" alt="$ A \in R^{m \times n}$" src="form_13.png"/> solves <img class="formulaInl" alt="$ \min_x \|Ax - b\|$" src="form_14.png"/> or <img class="formulaInl" alt="$ \min_x \|A^T x - b\|$" src="form_15.png"/> if m &gt;= n, or it finds the minimum norm solution of <img class="formulaInl" alt="$ Ax = b $" src="form_16.png"/> or <img class="formulaInl" alt="$ A^T x = b $" src="form_17.png"/> if m &lt; n, so that <img class="formulaInl" alt="$ Ax = b$" src="form_18.png"/> is underdetermined. A must have full rank.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">Matrix</a> A. Will be overwritten by QR or LQ decompositions. </td></tr>
    <tr><td class="paramname">transA</td><td>If true, A is used transposed. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side vector. Will be overwritten with the solution vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>Appears not to work -- needs testing (examples/lapack.cpp) </dd></dl>

</div>
</div>
<a class="anchor" id="gad9bce46639a52486fbc3075e53dc094e"></a><!-- doxytag: member="goMath::Lapack::gelss" ref="gad9bce46639a52486fbc3075e53dc094e" args="(matrix_type &amp;A, bool transA, vector_type &amp;b, vector_type *singularValues=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class matrix_type , class vector_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::Lapack::gelss </td>
          <td>(</td>
          <td class="paramtype">matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type *&#160;</td>
          <td class="paramname"><em>singularValues</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lapack gelss. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>NEEDS TESTING, UNTESTED. Possibly the LDA is wrong if the matrix is not square (which is true in general).</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td></td></tr>
    <tr><td class="paramname">transA</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">singularValues</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gaef0fe84b124840f509bdd66c8eb39464"></a><!-- doxytag: member="goMath::Lapack::getrf" ref="gaef0fe84b124840f509bdd66c8eb39464" args="(matrix_type &amp;A, pivot_vector &amp;ipiv)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class matrix_type , class pivot_vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::Lapack::getrf </td>
          <td>(</td>
          <td class="paramtype">matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pivot_vector &amp;&#160;</td>
          <td class="paramname"><em>ipiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lapack getrf. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Uses ATLAS' clapack implementation.</dd></dl>
<p>Replaces A by its LU-decomposed form, <img class="formulaInl" alt="$ A \gets LU, \, ipiv \gets P $" src="form_10.png"/> so that <img class="formulaInl" alt="$ AP = LU \, . $" src="form_11.png"/> U is unit diagonal, P pivots columns. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">Matrix</a> to be decomposed. </td></tr>
    <tr><td class="paramname">ipiv</td><td>Pivot vector (filled by this function).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaec7ce00d0fcba96cab92198340330b6b"></a><!-- doxytag: member="goMath::Lapack::getri" ref="gaec7ce00d0fcba96cab92198340330b6b" args="(matrix_type &amp;A, const pivot_vector &amp;ipiv)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class matrix_type , class pivot_vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::Lapack::getri </td>
          <td>(</td>
          <td class="paramtype">matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pivot_vector &amp;&#160;</td>
          <td class="paramname"><em>ipiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lapack getri, invert a LU-decomposed matrix. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Uses ATLAS' clapack implementation.</dd></dl>
<p>The matrix must be in LU-form created by <a class="el" href="group__mathla.html#gaef0fe84b124840f509bdd66c8eb39464" title="Lapack getrf.">getrf()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">Matrix</a> to invert. Must be in <a class="el" href="classgoMath_1_1LU.html" title="LU Decomposition.">LU</a> form and must be quadratic. </td></tr>
    <tr><td class="paramname">ipiv</td><td>Pivot vector as created by <a class="el" href="group__mathla.html#gaef0fe84b124840f509bdd66c8eb39464" title="Lapack getrf.">getrf()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gae345db3ca8faa550f002a0bc22cd72a4"></a><!-- doxytag: member="goMath::Lapack::getrs" ref="gae345db3ca8faa550f002a0bc22cd72a4" args="(const matrix_type &amp;A, bool transA, matrix_type &amp;B, const pivot_vector &amp;ipiv)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class matrix_type , class pivot_vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::Lapack::getrs </td>
          <td>(</td>
          <td class="paramtype">const matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_type &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pivot_vector &amp;&#160;</td>
          <td class="paramname"><em>ipiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lapack getrs. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Uses ATLAS' clapack implementation.</dd></dl>
<p>Solves <img class="formulaInl" alt="$ A x = B^\top $" src="form_12.png"/> for x, assuming A is LU-decomposed e.g. with <a class="el" href="group__mathla.html#gaef0fe84b124840f509bdd66c8eb39464" title="Lapack getrf.">getrf()</a>. Implemented for goFloat and goDouble. pivot_vector must be of type <code>int</code>, and provide getSize(), resize() as well as getPtr() methods (such as <a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">goMath::Vector</a>). matrix_type must essentially be <a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">goMath::Matrix</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>B contains the right hand side vectors in its <b>rows</b>. Always remember this. This is apparently an effect of using row major order which stems from ATLAS.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">Matrix</a> A </td></tr>
    <tr><td class="paramname">transA</td><td>Use A transposed </td></tr>
    <tr><td class="paramname">B</td><td>Right hand side (the right hand side vectors are in the <code>rows</code> of B, not the columns!). On success, the rows contain the solutions. </td></tr>
    <tr><td class="paramname">ipiv</td><td>Pivot vector (from <a class="el" href="group__mathla.html#gaef0fe84b124840f509bdd66c8eb39464" title="Lapack getrf.">getrf()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a20bf18bfad14416d95c940492202d4"></a><!-- doxytag: member="goMath::matrixMult" ref="ga1a20bf18bfad14416d95c940492202d4" args="(T alpha, const goMath::Matrix&lt; T &gt; &amp;A, bool transA, const goMath::Matrix&lt; T &gt; &amp;B, bool transB, T beta, goMath::Matrix&lt; T &gt; &amp;C)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void goMath::matrixMult </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate <img class="formulaInl" alt="$C = \alpha \cdot A \cdot B + \beta \cdot C $" src="form_25.png"/>. </p>
<p>A and B can optionally be used as transpose. This function uses CBLAS functions.</p>
<p>This function is implemented for goFloat and goDouble, using cblas_[s|d]gemm functions from CBLAS.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Multiplicative factor for A </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">Matrix</a> A </td></tr>
    <tr><td class="paramname">transA</td><td>If true, A will be used transposed. </td></tr>
    <tr><td class="paramname">B</td><td><a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">Matrix</a> B </td></tr>
    <tr><td class="paramname">transB</td><td>If true, B will be used transposed. </td></tr>
    <tr><td class="paramname">beta</td><td>Multiplicative factor for C </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">Matrix</a> C, also holds the result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6976b4170ff78b845a56bd9be509d34b"></a><!-- doxytag: member="goMath::matrixVectorMult" ref="ga6976b4170ff78b845a56bd9be509d34b" args="(T alpha, const goMath::Matrix&lt; T &gt; &amp;A, bool transA, const goMath::Vector&lt; T &gt; &amp;x, T beta, goMath::Vector&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::matrixVectorMult </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>calculate <img class="formulaInl" alt="$ y = \alpha A x + \beta y $" src="form_26.png"/>. </p>
<p>Sizes of A and x are checked. If y has mismatching size, it is resized and initialised with 0 before the operation.</p>
<p>Parameters are named as in the formula above.</p>
<p>Uses cblas_&lt;&gt;gemv().</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd>TEST THIS FUNCTION.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar factor </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">Matrix</a> A </td></tr>
    <tr><td class="paramname">transA</td><td>If true, A is used as transposed. </td></tr>
    <tr><td class="paramname">x</td><td><a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">Vector</a> x </td></tr>
    <tr><td class="paramname">beta</td><td>Scalar factor (for y) </td></tr>
    <tr><td class="paramname">y</td><td><a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">Vector</a> y, also holds the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2182f8f21e6e07038ffc5126d0c99a3f"></a><!-- doxytag: member="goMath::Lapack::posv" ref="ga2182f8f21e6e07038ffc5126d0c99a3f" args="(matrix_type &amp;A, matrix_type &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class matrix_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::Lapack::posv </td>
          <td>(</td>
          <td class="paramtype">matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix_type &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lapack *posv procedure for solving symmetric linear systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Symmetric matrix, no special storage, must be upper right. </td></tr>
    <tr><td class="paramname">b</td><td>Contains the right hand side vectors <b>in its rows</b>. This is due to the actual lapack routine using column major storage and we use the more C-like row major. Contains the solutions if the method returns true. The solutions are contained <b>in the rows</b>, again because of the underlying routine using column major storage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga644670c32dd181c83c5f0e6f060e68dc"></a><!-- doxytag: member="goMath::Lapack::posv" ref="ga644670c32dd181c83c5f0e6f060e68dc" args="(matrix_type &amp;A, vector_type &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class matrix_type , class vector_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::Lapack::posv </td>
          <td>(</td>
          <td class="paramtype">matrix_type &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_type &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lapack *posv procedure for solving symmetric linear systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Symmetric matrix, no special storage, must be upper right. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side vector. Contains the solution if the method returns true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gab09c61d1d33f52541fc92d5d4d02c10a"></a><!-- doxytag: member="goMath::vectorAdd" ref="gab09c61d1d33f52541fc92d5d4d02c10a" args="(T alpha, const Vector&lt; T &gt; &amp;x, Vector&lt; T &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::vectorAdd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>y = alpha * x + y </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Implemented for goDouble and goFloat</dd></dl>
<p>Uses cblas_&lt;&gt;axpy functions. Sizes of x and y must match and are checked for.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar factor </td></tr>
    <tr><td class="paramname">x</td><td><a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">Vector</a> x </td></tr>
    <tr><td class="paramname">y</td><td><a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">Vector</a> y</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b1c345b0afa0ce9ed0a40a9e61085d0"></a><!-- doxytag: member="goMath::vectorOuter" ref="ga6b1c345b0afa0ce9ed0a40a9e61085d0" args="(T alpha, const Vector&lt; T &gt; &amp;x, const Vector&lt; T &gt; &amp;y, goMath::Matrix&lt; T &gt; &amp;ret)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void goMath::vectorOuter </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Outer vector product <img class="formulaInl" alt="$ A = A + \alpha \cdot x \cdot y^\top $" src="form_56.png"/>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Implemented for goDouble and goFloat using cblas_&lt;&gt;ger(). Other types are directly implemented and therefore slower in most implementations.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scalar factor </td></tr>
    <tr><td class="paramname">x</td><td><a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">Vector</a> x of size M </td></tr>
    <tr><td class="paramname">y</td><td><a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">Vector</a> y of size N </td></tr>
    <tr><td class="paramname">ret</td><td>Return matrix A, of size MxN. Resized and initialised to 0 if it does not have the right size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Mon Mar 12 2012 20:46:18 for golib by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
