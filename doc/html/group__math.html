<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>golib: Mathematics and numerics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">golib&#160;<span id="projectnumber">0.5</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__math.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#groups">Modules</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mathematics and numerics</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo3Vector.html">go3Vector&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">3-dimensional vector.  <a href="classgo3Vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoBiorthoWavelet.html">goBiorthoWavelet</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoComplex.html">goComplex&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number class.  <a href="classgoComplex.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1CubicSpline.html">goMath::CubicSpline&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic interpolating splines.  <a href="classgoMath_1_1CubicSpline.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1CubicSplineND.html">goMath::CubicSplineND&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic interpolating splines.  <a href="classgoMath_1_1CubicSplineND.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoCurve.html">goCurve&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Curve representation.  <a href="classgoCurve.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignal_1_1TVL1.html">goSignal::TVL1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TV-regularised L1-norm approximation of an image after [1].  <a href="classgoSignal_1_1TVL1.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1GaussPDF.html">goMath::GaussPDF&lt; input_type, output_type &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gauss' probability density function.  <a href="classgoMath_1_1GaussPDF.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1MultiGaussPDF.html">goMath::MultiGaussPDF&lt; input_vector, scalar_type &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">Vector</a> values Gauss distribution.  <a href="classgoMath_1_1MultiGaussPDF.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1Manifold.html">goMath::Manifold&lt; element_type, tangent_type &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for manifolds.  <a href="classgoMath_1_1Manifold.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1SO3.html">goMath::SO3&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotation group.  <a href="classgoMath_1_1SO3.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1LinearSpace.html">goMath::LinearSpace&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple linear vector space.  <a href="classgoMath_1_1LinearSpace.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1UnitSphere.html">goMath::UnitSphere&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit sphere.  <a href="classgoMath_1_1UnitSphere.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1PDF.html">goMath::PDF&lt; input_type, output_type &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Probability density function base template.  <a href="classgoMath_1_1PDF.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoPointCloud.html">goPointCloud&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Point cloud.  <a href="classgoPointCloud.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoQuaternion.html">goQuaternion&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Quaternion class.  <a href="classgoQuaternion.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic sparse matrix class with Matlab mxArray support.  <a href="classgoSparseMatrix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoMath_1_1ThinSVD.html">goMath::ThinSVD&lt; Real &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mathla.html">Linear Algebra</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mathopt.html">Optimisation</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classgo4Vector.html">go4Vector</a>&lt; goFloat &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gae2906047eff53025853e62461ed394a0">go4Vectorf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">4-dimensional vector.  <a href="#gae2906047eff53025853e62461ed394a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa974089b5bcfad7418c436a4b6a11bce"></a><!-- doxytag: member="math::go4Vectord" ref="gaa974089b5bcfad7418c436a4b6a11bce" args="" -->
typedef <a class="el" href="classgo4Vector.html">go4Vector</a>&lt; goDouble &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>go4Vectord</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf95dae78dfa080fcbb5073bff234488"></a><!-- doxytag: member="math::goCurvef" ref="gacf95dae78dfa080fcbb5073bff234488" args="" -->
typedef <a class="el" href="classgoCurve.html">goCurve</a>&lt; goFloat &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>goCurvef</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac2f09ca10dbc4864c604b732e4907823"></a><!-- doxytag: member="math::goCurved" ref="gac2f09ca10dbc4864c604b732e4907823" args="" -->
typedef <a class="el" href="classgoCurve.html">goCurve</a>&lt; goDouble &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>goCurved</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga15f43a3402f4ad3e097a007f2b2d8921"></a><!-- doxytag: member="math::goPointCloudf" ref="ga15f43a3402f4ad3e097a007f2b2d8921" args="" -->
typedef <a class="el" href="classgoPointCloud.html">goPointCloud</a>&lt; goFloat &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>goPointCloudf</b></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class iterator_type , class manifold_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga02e7707ad113a5c299a186f914626279">goMath::karcherMean</a> (iterator_type start, int count, manifold_type &amp;manifold, typename manifold_type::Element &amp;meanRet, int max_iterations=1000, double epsilon=1e-6)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Karcher mean for generic Riemannian manifolds.  <a href="#ga02e7707ad113a5c299a186f914626279"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gac66533de3266bba340fa0eda90b506ef">goMath::mod</a> (T value, T modulus)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulus function.  <a href="#gac66533de3266bba340fa0eda90b506ef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Real &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga37e90cad530325a2021e148cd6198675">goMath::abs</a> (Real a)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Real &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gab40399142d8cd9e3aeb2e5e60e0c3ef3">goMath::hypot</a> (const Real &amp;a, const Real &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Real &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga56083240e697b696b8cd558c8338e5dd">goMath::acos</a> (const Real &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga588f091922b9107a7a34d3c8193be121">goMath::min</a> (Scalar a, Scalar b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gaa3e7b0370f4f4d5be1e682b31341bb84">goMath::max</a> (Scalar a, Scalar b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gacc02e666cd84a1c4008e9064769899c6"></a><!-- doxytag: member="math::max" ref="gacc02e666cd84a1c4008e9064769899c6" args="(const goFixedArray&lt; T &gt; &amp;a)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>goMath::max</b> (const <a class="el" href="classgoFixedArray.html">goFixedArray</a>&lt; T &gt; &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga06ec2c29911a1aec88c3ab9dd3764f60"></a><!-- doxytag: member="math::maxIndex" ref="ga06ec2c29911a1aec88c3ab9dd3764f60" args="(const goFixedArray&lt; T &gt; &amp;a)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="gotypes_8h.html#a02284d9088a729cca83dc808dd409e09">goSize_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>goMath::maxIndex</b> (const <a class="el" href="classgoFixedArray.html">goFixedArray</a>&lt; T &gt; &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2656a3f3b09c9fe9be60b865c4e57632"></a><!-- doxytag: member="math::min" ref="ga2656a3f3b09c9fe9be60b865c4e57632" args="(const goFixedArray&lt; T &gt; &amp;a)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>goMath::min</b> (const <a class="el" href="classgoFixedArray.html">goFixedArray</a>&lt; T &gt; &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf5ad2ea90f826937abcb9c1e4d00c98d"></a><!-- doxytag: member="math::minIndex" ref="gaf5ad2ea90f826937abcb9c1e4d00c98d" args="(const goFixedArray&lt; T &gt; &amp;a)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="gotypes_8h.html#a02284d9088a729cca83dc808dd409e09">goSize_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>goMath::minIndex</b> (const <a class="el" href="classgoFixedArray.html">goFixedArray</a>&lt; T &gt; &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5e99470615f20e2aa5c6088f2ab43042"></a><!-- doxytag: member="math::maxabs" ref="ga5e99470615f20e2aa5c6088f2ab43042" args="(const goFixedArray&lt; T &gt; &amp;a)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>goMath::maxabs</b> (const <a class="el" href="classgoFixedArray.html">goFixedArray</a>&lt; T &gt; &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3d6b0032cad3ae2d930ca5523757695e"></a><!-- doxytag: member="math::minabs" ref="ga3d6b0032cad3ae2d930ca5523757695e" args="(const goFixedArray&lt; T &gt; &amp;a)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>goMath::minabs</b> (const <a class="el" href="classgoFixedArray.html">goFixedArray</a>&lt; T &gt; &amp;a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad43dd5a2ec63d91fe9c732722dba002f"></a><!-- doxytag: member="math::goSparseMatrix" ref="gad43dd5a2ec63d91fe9c732722dba002f" args="(int rows=0, int cols=0)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::goSparseMatrix</b> (int rows=0, int cols=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf927ff518112d347ba513f3f2d42e50"></a><!-- doxytag: member="math::init" ref="gadf927ff518112d347ba513f3f2d42e50" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::init</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaced3b05c4947e9349d3b9b9d3fd0d3dc"></a><!-- doxytag: member="math::setSize" ref="gaced3b05c4947e9349d3b9b9d3fd0d3dc" args="(int rows, int cols)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::setSize</b> (int rows, int cols)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gab4dbc2d797d135840fb504509b5410fa">goSparseMatrix::set</a> (int row, int col, double value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented.  <a href="#gab4dbc2d797d135840fb504509b5410fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaaa12bb1fe580f2a6d78b8a1a3cc00af5">goSparseMatrix::getElementCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of nonzero elements.  <a href="#gaaa12bb1fe580f2a6d78b8a1a3cc00af5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6755b6845bf6361f0bc3364749196f93"></a><!-- doxytag: member="math::getSortType" ref="ga6755b6845bf6361f0bc3364749196f93" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::getSortType</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga4695915a5b6160a9c0a5bc92ee61db76">goSparseMatrix::fillBegin</a> (int elementCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin filling elementCount elements in this matrix.  <a href="#ga4695915a5b6160a9c0a5bc92ee61db76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga3a0b7de82ad4994c21f296b1d6984020">goSparseMatrix::fillNext</a> (int row, int col, double value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the next element in this matrix.  <a href="#ga3a0b7de82ad4994c21f296b1d6984020"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga52518eeb9a2a05e244c3adc04a16e383">goSparseMatrix::fillEnd</a> (int sortType=ROW_WISE)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends filling the matrix.  <a href="#ga52518eeb9a2a05e244c3adc04a16e383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gacd2a07bfe5dc51bad6d5e46e425ec934">goSparseMatrix::matrixVectorMult</a> (<a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;ret, const <a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">(this) * v  <a href="#gacd2a07bfe5dc51bad6d5e46e425ec934"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Tv &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga392c79b5192254540d7fc7f9de1840c0">goSparseMatrix::matrixVectorMult</a> (<a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; Tv &gt; &amp;ret, const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; Tv &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">(this) * v  <a href="#ga392c79b5192254540d7fc7f9de1840c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga79dd3aa87e401b441e4cb7a37674c40c">goSparseMatrix::vectorMatrixMult</a> (<a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;ret, const <a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">v' * (this)  <a href="#ga79dd3aa87e401b441e4cb7a37674c40c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga03285f3737a34d3bbc0670f0711b2f2d">goSparseMatrix::matrixVectorMult</a> (<a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;ret, const <a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">(this) * v  <a href="#ga03285f3737a34d3bbc0670f0711b2f2d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Tv &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga17f4a106b834da91b7b404a85a7d3668">goSparseMatrix::matrixVectorMult</a> (<a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;ret, const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; Tv &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">(this) * v  <a href="#ga17f4a106b834da91b7b404a85a7d3668"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gabfe54e23447b84494a172c12d645c51e">goSparseMatrix::vectorMatrixMult</a> (<a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;ret, const <a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">v' * (this)  <a href="#gabfe54e23447b84494a172c12d645c51e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga571736d5ded8f5967c258283d06abce6"></a><!-- doxytag: member="math::matrixMatrixMult" ref="ga571736d5ded8f5967c258283d06abce6" args="(goSparseMatrix &amp;ret, goSparseMatrix &amp;m)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::matrixMatrixMult</b> (<a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;ret, <a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga48d022609a6947c876f084bdb87b4539"></a><!-- doxytag: member="math::matrixMatrixAdd" ref="ga48d022609a6947c876f084bdb87b4539" args="(goSparseMatrix &amp;ret, goSparseMatrix &amp;m)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::matrixMatrixAdd</b> (<a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;ret, <a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab5fb60f977bc4753dad11b2d82682868"></a><!-- doxytag: member="math::matrixMatrixSubtract" ref="gab5fb60f977bc4753dad11b2d82682868" args="(goSparseMatrix &amp;ret, goSparseMatrix &amp;m)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::matrixMatrixSubtract</b> (<a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;ret, <a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab562c01dc2eb0195dd4a7cf6ad71c958"></a><!-- doxytag: member="math::operator*=" ref="gab562c01dc2eb0195dd4a7cf6ad71c958" args="(goDouble scalar)" -->
<a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::operator*=</b> (goDouble scalar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91324766a38c90611e8432caaec206fb"></a><!-- doxytag: member="math::operator*" ref="ga91324766a38c90611e8432caaec206fb" args="(const goSparseMatrix &amp;other) const " -->
<a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::operator*</b> (const <a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;other) const </td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf69d16b55d39247c08706d2c09f1cfa6"></a><!-- doxytag: member="math::operator*" ref="gaf69d16b55d39247c08706d2c09f1cfa6" args="(const goMath::Vector&lt; Tv &gt; &amp;v) const " -->
template&lt;class Tv &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; Tv &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>goSparseMatrix::operator*</b> (const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; Tv &gt; &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab8fd55f79852220aee41d088403cb81a"></a><!-- doxytag: member="math::operator*" ref="gab8fd55f79852220aee41d088403cb81a" args="(goDouble s) const " -->
<a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::operator*</b> (goDouble s) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a734a29eed6b57fff8badd0a56804fc"></a><!-- doxytag: member="math::operator+" ref="ga4a734a29eed6b57fff8badd0a56804fc" args="(const goSparseMatrix &amp;m) const " -->
<a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::operator+</b> (const <a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;m) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1dd1e574d9af047a6092022b877849e"></a><!-- doxytag: member="math::operator&#45;" ref="gaa1dd1e574d9af047a6092022b877849e" args="(const goSparseMatrix &amp;m) const " -->
<a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::operator-</b> (const <a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;m) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaae7aa5ce83c1dceb7942ac8c67be23e7"></a><!-- doxytag: member="math::row" ref="gaae7aa5ce83c1dceb7942ac8c67be23e7" args="(goIndex_t elementIndex) const " -->
goIndex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaae7aa5ce83c1dceb7942ac8c67be23e7">goSparseMatrix::row</a> (goIndex_t elementIndex) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the row of the element at elementIndex. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9574773cca9f6280de183f91061855ad"></a><!-- doxytag: member="math::column" ref="ga9574773cca9f6280de183f91061855ad" args="(goIndex_t elementIndex) const " -->
goIndex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga9574773cca9f6280de183f91061855ad">goSparseMatrix::column</a> (goIndex_t elementIndex) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the row of the element at elementIndex. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7480841a9bffc33fffc8b45e037d0464"></a><!-- doxytag: member="math::value" ref="ga7480841a9bffc33fffc8b45e037d0464" args="(goIndex_t elementIndex) const " -->
goDouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga7480841a9bffc33fffc8b45e037d0464">goSparseMatrix::value</a> (goIndex_t elementIndex) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the element at elementIndex. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0c54c4bae80b2acbe008df1f4a1829b5"></a><!-- doxytag: member="math::getRowCount" ref="ga0c54c4bae80b2acbe008df1f4a1829b5" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga0c54c4bae80b2acbe008df1f4a1829b5">goSparseMatrix::getRowCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga20d895f52ddf7be2cff6996cece909fa"></a><!-- doxytag: member="math::getColumnCount" ref="ga20d895f52ddf7be2cff6996cece909fa" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga20d895f52ddf7be2cff6996cece909fa">goSparseMatrix::getColumnCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga35d779ebb74f91e9336ed73d943243cc"></a><!-- doxytag: member="math::getRowStart" ref="ga35d779ebb74f91e9336ed73d943243cc" args="() const " -->
const <a class="el" href="classgoArray.html">goArray</a>&lt; goIndex_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga35d779ebb74f91e9336ed73d943243cc">goSparseMatrix::getRowStart</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For row-sorted matrices. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae8fa7fbc23e18280419f53e401c85ffb"></a><!-- doxytag: member="math::getColStart" ref="gae8fa7fbc23e18280419f53e401c85ffb" args="() const " -->
const <a class="el" href="classgoArray.html">goArray</a>&lt; goIndex_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gae8fa7fbc23e18280419f53e401c85ffb">goSparseMatrix::getColStart</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For column-sorted matrices. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga53e5f8bca9b600f2d05706b52d2e0fff">goSparseMatrix::sortRows</a> (bool sort_columns=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts in ascending row order.  <a href="#ga53e5f8bca9b600f2d05706b52d2e0fff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa7f4aac5015bddc813ff7248a242e4bd">goSparseMatrix::sortColumns</a> (bool sort_rows=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts in ascending column order.  <a href="#gaa7f4aac5015bddc813ff7248a242e4bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabfd926c2062e999ce606238c70efe83c"></a><!-- doxytag: member="math::findRows" ref="gabfd926c2062e999ce606238c70efe83c" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::findRows</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga136025d6237fc470fe8c457b5de379a3"></a><!-- doxytag: member="math::findColumns" ref="ga136025d6237fc470fe8c457b5de379a3" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::findColumns</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2732c10de17e982ab094d5f1c9a71508">goSparseMatrix::appendRow</a> (const <a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the row matrix r to this matrix.  <a href="#ga2732c10de17e982ab094d5f1c9a71508"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gae9ee7a28e82206ad416f4c811272f13b">goSparseMatrix::appendRows</a> (const <a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac614c08cb18f506fe6be34cd2a734838"></a><!-- doxytag: member="math::transpose" ref="gac614c08cb18f506fe6be34cd2a734838" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::transpose</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae8ea1510bd774e2f7a98c14aef52aa1f"></a><!-- doxytag: member="math::getColIndex" ref="gae8ea1510bd774e2f7a98c14aef52aa1f" args="()" -->
<a class="el" href="classgoArray.html">goArray</a>&lt; goIndex_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::getColIndex</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27f6f2ff6dd325e872d23d08c83e6982"></a><!-- doxytag: member="math::getColIndex" ref="ga27f6f2ff6dd325e872d23d08c83e6982" args="() const " -->
const <a class="el" href="classgoArray.html">goArray</a>&lt; goIndex_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::getColIndex</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac2fcfe556e7c379696f7e01cc8d50ef5"></a><!-- doxytag: member="math::getRowIndex" ref="gac2fcfe556e7c379696f7e01cc8d50ef5" args="()" -->
<a class="el" href="classgoArray.html">goArray</a>&lt; goIndex_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::getRowIndex</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7ebc509e45c3eeeaa8656fc76508e697"></a><!-- doxytag: member="math::getRowIndex" ref="ga7ebc509e45c3eeeaa8656fc76508e697" args="() const " -->
const <a class="el" href="classgoArray.html">goArray</a>&lt; goIndex_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::getRowIndex</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa09c2e8832e708d0c674141f6be5db19"></a><!-- doxytag: member="math::getValues" ref="gaa09c2e8832e708d0c674141f6be5db19" args="()" -->
<a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::getValues</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9443a5769f4a5f4af92b78386755df0b"></a><!-- doxytag: member="math::getValues" ref="ga9443a5769f4a5f4af92b78386755df0b" args="() const " -->
const <a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::getValues</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4e7b9c0a5b40ad9a681b3d3429d977fe"></a><!-- doxytag: member="math::setSortType" ref="ga4e7b9c0a5b40ad9a681b3d3429d977fe" args="(int t)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>goSparseMatrix::setSortType</b> (int t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga15c976883a1d944da81950003995249d">goMath::euclideanToBarycentric</a> (const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;simplex, const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;point, <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;ret)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert euclidean to barycentric coordinates.  <a href="#ga15c976883a1d944da81950003995249d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">goDouble&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gae33acfc40a189829345d72d2d5dacf7c">goMath::goConjugateGradients</a> (const MatrixType &amp;A, const VectorType &amp;b, VectorType &amp;x, goDouble epsilon=1e-6)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conjugate gradients solver.  <a href="#gae33acfc40a189829345d72d2d5dacf7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gab7d59c331113599237c2cd4f801e73db">goMath::resampleCubic</a> (const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;source, <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;target, <a class="el" href="gotypes_8h.html#a02284d9088a729cca83dc808dd409e09">goSize_t</a> resamplePointCount, bool closed=false, <a class="el" href="classgoFixedArray.html">goFixedArray</a>&lt; goDouble &gt; *accumLength_=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Piecewise cubic resampling of a curve represented by a configuration matrix.  <a href="#gab7d59c331113599237c2cd4f801e73db"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gac8ac4f92c82e0e3366733273a380fcd6"></a><!-- doxytag: member="math::resampleLinear" ref="gac8ac4f92c82e0e3366733273a380fcd6" args="(const goFixedArray&lt; T &gt; &amp;f, goFixedArray&lt; T &gt; &amp;ret)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>goMath::resampleLinear</b> (const <a class="el" href="classgoFixedArray.html">goFixedArray</a>&lt; T &gt; &amp;f, <a class="el" href="classgoFixedArray.html">goFixedArray</a>&lt; T &gt; &amp;ret)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga25bf56fbb35cd6837d8c0696b1b8065b">goMath::laplacian2D</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;retValue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the laplacian (2nd derivative) of a 2D signal (z-size == 1).  <a href="#ga25bf56fbb35cd6837d8c0696b1b8065b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gadd653cdd30778e71f672cf5c87ea2d35">goMath::gradient2D</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;retValue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the gradient of a 2D signal (z-size == 1).  <a href="#gadd653cdd30778e71f672cf5c87ea2d35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga9926b0fb639ce4a5e8d91bc6c5655456">goMath::ddx2D</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;retValue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivative in x direction assuming a 2D signal.  <a href="#ga9926b0fb639ce4a5e8d91bc6c5655456"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga836ba805e0a5c75485ac8e3217f923c2">goMath::ddy2D</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;retValue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivative in y direction assuming a 2D signal.  <a href="#ga836ba805e0a5c75485ac8e3217f923c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2eac7c2fbdc0f7b46486b2d4ad74698c">goMath::centralDifferences</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;x, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;retValue, int dimension=0, goDouble h=1.0, const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *mask=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate central finite differences in a given direction.  <a href="#ga2eac7c2fbdc0f7b46486b2d4ad74698c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gab044c522e1313099d520307a7bb28efe">goMath::forwardDifferences</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;x, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;retValue, int dimension=0, goDouble h=1.0, const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *mask=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate forward finite differences in a given direction.  <a href="#gab044c522e1313099d520307a7bb28efe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga35d54daaa769343f6fbbd05138e6cfb9">goMath::backwardDifferences</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;x, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;retValue, int dimension=0, goDouble h=1.0, const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *mask=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate backward finite differences in a given direction.  <a href="#ga35d54daaa769343f6fbbd05138e6cfb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2bac245060bf741a3549d26cdea7d701"></a><!-- doxytag: member="math::curvatureDirect2D" ref="ga2bac245060bf741a3549d26cdea7d701" args="(const goSignal3DBase&lt; void &gt; &amp;input, goSignal3D&lt; void &gt; &amp;result, goDouble hx=1.0, goDouble hy=1.0)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>goMath::curvatureDirect2D</b> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;input, <a class="el" href="classgoSignal3D.html">goSignal3D</a>&lt; void &gt; &amp;result, goDouble hx=1.0, goDouble hy=1.0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga906443556e27c0335fb8db0209fa4f5a">goMath::integrate</a> (const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sehnentrapezformel. Step width (h) is assumed 1, so normalisation may be needed afterwards.  <a href="#ga906443556e27c0335fb8db0209fa4f5a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga5d3b2f36754c98a79b96182a8e68f829">goMath::integrateSimpson</a> (const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration with Simpson rule. Step width h is assumed 1, so normalisation may be needed afterwards.  <a href="#ga5d3b2f36754c98a79b96182a8e68f829"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3a00e35a8a59fd6b357198e802505a05"></a><!-- doxytag: member="math::integrateSum" ref="ga3a00e35a8a59fd6b357198e802505a05" args="(const goMath::Vector&lt; T &gt; &amp;v)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>goMath::integrateSum</b> (const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga6a01e8162c28f8c719683e75c0c395bc">goMath::stencil</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate <img class="formulaInl" alt="$ \sum_{i,j} sig(i,j,0) \cdot s(i,j) $" src="form_68.png"/>.  <a href="#ga6a01e8162c28f8c719683e75c0c395bc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gab066ef2296a543ba92e3acadfea35243">goSignal::binaryImage</a> (const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;boundary, <a class="el" href="classgoSignal3D.html">goSignal3D</a>&lt; void &gt; &amp;ret, <a class="el" href="gotypes_8h.html#a02284d9088a729cca83dc808dd409e09">goSize_t</a> width, <a class="el" href="gotypes_8h.html#a02284d9088a729cca83dc808dd409e09">goSize_t</a> height)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a binary image bounded by the closed curve described by the Nx2 point configuration matrix <code>boundary</code>.  <a href="#gab066ef2296a543ba92e3acadfea35243"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga3575386b808acff1ac42aabcd0c748f7">goMath::transform2D</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;source, goDouble scale, goDouble angle, goDouble t_x, goDouble t_y, <a class="el" href="classgoSignal3D.html">goSignal3D</a>&lt; void &gt; &amp;target, bool setsize=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">2D euclidean transformation of an image.  <a href="#ga3575386b808acff1ac42aabcd0c748f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga51ff1eaa8f69b4aaa6b07142d1c00c3d">goMath::scale2D</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;source, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;target, bool keep_aspect=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale <code>source</code> into <code>target</code>.  <a href="#ga51ff1eaa8f69b4aaa6b07142d1c00c3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga785a0487be36455e9172992f64c90a17">goMath::paste2D</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;source, goDouble scale, goDouble angle, goDouble t_x, goDouble t_y, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;target, goFloat bgColour)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Paste <code>source</code> at under some euclidean transformations into <code>target</code>.  <a href="#ga785a0487be36455e9172992f64c90a17"></a><br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gae2906047eff53025853e62461ed394a0"></a><!-- doxytag: member="go4vector.h::go4Vectorf" ref="gae2906047eff53025853e62461ed394a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classgo4Vector.html">go4Vector</a>&lt;goFloat&gt; <a class="el" href="classgo4Vector.html">go4Vectorf</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>4-dimensional vector. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>make this a descendant of <a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">goMath::Vector</a>, fix size to 4, provide x,y,z,t/w as references. </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga37e90cad530325a2021e148cd6198675"></a><!-- doxytag: member="goMath::abs" ref="ga37e90cad530325a2021e148cd6198675" args="(Real a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Real goMath::abs </td>
          <td>(</td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the absolute value of a real (no-complex) scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="ga56083240e697b696b8cd558c8338e5dd"></a><!-- doxytag: member="goMath::acos" ref="ga56083240e697b696b8cd558c8338e5dd" args="(const Real &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Real goMath::acos </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>::acos seems to result in nan when the argument is exactly 1.0 (contrary to the manpage!). That is caught here. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>acos (a) </dd></dl>

</div>
</div>
<a class="anchor" id="ga2732c10de17e982ab094d5f1c9a71508"></a><!-- doxytag: member="goSparseMatrix::appendRow" ref="ga2732c10de17e982ab094d5f1c9a71508" args="(const goSparseMatrix &amp;r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSparseMatrix::appendRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends the row matrix r to this matrix. </p>
<p>The result is [(*this)' r']'</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Must be of size (1, this-&gt;<a class="el" href="group__math.html#ga20d895f52ddf7be2cff6996cece909fa" title="Returns the number of columns.">getColumnCount()</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gae9ee7a28e82206ad416f4c811272f13b"></a><!-- doxytag: member="goSparseMatrix::appendRows" ref="gae9ee7a28e82206ad416f4c811272f13b" args="(const goSparseMatrix &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSparseMatrix::appendRows </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000009">Bug:</a></b></dt><dd>After appending rows, findRows() should be called when this matrix is row-sorted. This needs to be fixed or it will lead to misunderstandings and malfunctioning code/hard to find errors. </dd></dl>

</div>
</div>
<a class="anchor" id="ga35d54daaa769343f6fbbd05138e6cfb9"></a><!-- doxytag: member="goMath::backwardDifferences" ref="ga35d54daaa769343f6fbbd05138e6cfb9" args="(const goSignal3DBase&lt; void &gt; &amp;x, goSignal3DBase&lt; void &gt; &amp;retValue, int dimension=0, goDouble h=1.0, const goSignal3DBase&lt; void &gt; *mask=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::backwardDifferences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>retValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>h</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>mask</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate backward finite differences in a given direction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Data grid. </td></tr>
    <tr><td class="paramname">retValue</td><td>Contains finite differences after the function returns true. If the size of retValue does not match the size of x and retValue is a <a class="el" href="classgoSignal3D.html">goSignal3D&lt;void&gt;</a>, retValue will be resized to the size of x, including number of channels, blocksize of x and border of 1 in each direction. </td></tr>
    <tr><td class="paramname">dimension</td><td>Dimension (0, 1, or 2 for x, y, or z) </td></tr>
    <tr><td class="paramname">h</td><td>Grid spacing (default 1) </td></tr>
    <tr><td class="paramname">mask</td><td>Optional mask of type goInt8. If given, central differences are only calculated where mask is != 0. The other values in retValue are not changed. Default: NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Only goFloat and goDouble data are supported. The data types of x and retValue may differ. Both are given by the user, so the data type of retValue must be set before calling this function. It may be of wrong size, in which case it must point to a <a class="el" href="classgoSignal3D.html">goSignal3D&lt;void&gt;</a> in order for it to be resizable. </dd>
<dd>
The algorithm is run for all channels.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Christian Gosch </dd></dl>

</div>
</div>
<a class="anchor" id="gab066ef2296a543ba92e3acadfea35243"></a><!-- doxytag: member="goSignal::binaryImage" ref="gab066ef2296a543ba92e3acadfea35243" args="(const goMath::Matrix&lt; T &gt; &amp;boundary, goSignal3D&lt; void &gt; &amp;ret, goSize_t width, goSize_t height)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goSignal::binaryImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3D.html">goSignal3D</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gotypes_8h.html#a02284d9088a729cca83dc808dd409e09">goSize_t</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gotypes_8h.html#a02284d9088a729cca83dc808dd409e09">goSize_t</a>&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate a binary image bounded by the closed curve described by the Nx2 point configuration matrix <code>boundary</code>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>No bounds check is done, so if the curve points fall out of the bounds of the image size, (e.g. negative values), you will get segfaults.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary</td><td>Closed curve point configuration matrix. </td></tr>
    <tr><td class="paramname">ret</td><td>On return, contains the binary image. The type must be set by the user. </td></tr>
    <tr><td class="paramname">width</td><td>Width of the binary image </td></tr>
    <tr><td class="paramname">height</td><td>Width of the binary image</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2eac7c2fbdc0f7b46486b2d4ad74698c"></a><!-- doxytag: member="goMath::centralDifferences" ref="ga2eac7c2fbdc0f7b46486b2d4ad74698c" args="(const goSignal3DBase&lt; void &gt; &amp;x, goSignal3DBase&lt; void &gt; &amp;retValue, int dimension=0, goDouble h=1.0, const goSignal3DBase&lt; void &gt; *mask=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::centralDifferences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>retValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>h</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>mask</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate central finite differences in a given direction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Data grid. </td></tr>
    <tr><td class="paramname">retValue</td><td>Contains finite differences after the function returns true. If the size of retValue does not match the size of x and retValue is a <a class="el" href="classgoSignal3D.html">goSignal3D&lt;void&gt;</a>, retValue will be resized to the size of x, including number of channels, blocksize of x and border of 1 in each direction. </td></tr>
    <tr><td class="paramname">dimension</td><td>Dimension (0, 1, or 2 for x, y, or z) </td></tr>
    <tr><td class="paramname">h</td><td>Grid spacing (default 1) </td></tr>
    <tr><td class="paramname">mask</td><td>Optional mask of type goInt8. If given, central differences are only calculated where mask is != 0. The other values in retValue are not changed. Default: NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Only goFloat and goDouble data are supported. The data types of x and retValue may differ. Both are given by the user, so the data type of retValue must be set before calling this function. </dd>
<dd>
The algorithm is run for all channels.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Christian Gosch </dd></dl>

</div>
</div>
<a class="anchor" id="ga9926b0fb639ce4a5e8d91bc6c5655456"></a><!-- doxytag: member="goMath::ddx2D" ref="ga9926b0fb639ce4a5e8d91bc6c5655456" args="(const goSignal3DBase&lt; void &gt; &amp;sig, goSignal3DBase&lt; void &gt; &amp;retValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::ddx2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>retValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the derivative in x direction assuming a 2D signal. </p>
<p>This function calculates the derivative in x-direction while assuming the signal is 2-dimensional. The arguments are restricted to signals of type GO_FLOAT and GO_DOUBLE.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000067">Todo:</a></b></dt><dd>Implement for 3D-signals.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to calculate the derivative of. </td></tr>
    <tr><td class="paramname">retValue</td><td>After the function returned true, contains the x-derivative of sig. Must be of the same size as sig.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga836ba805e0a5c75485ac8e3217f923c2"></a><!-- doxytag: member="goMath::ddy2D" ref="ga836ba805e0a5c75485ac8e3217f923c2" args="(const goSignal3DBase&lt; void &gt; &amp;sig, goSignal3DBase&lt; void &gt; &amp;retValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::ddy2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>retValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the derivative in y direction assuming a 2D signal. </p>
<p>This function calculates the derivative in y-direction while assuming the signal is 2-dimensional. The arguments are restricted to signals of type GO_FLOAT and GO_DOUBLE.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000068">Todo:</a></b></dt><dd>Implement for 3D-signals.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to calculate the derivative of. </td></tr>
    <tr><td class="paramname">retValue</td><td>After the function returned true, contains the y-derivative of sig. Must be of the same size as sig.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga15c976883a1d944da81950003995249d"></a><!-- doxytag: member="goMath::euclideanToBarycentric" ref="ga15c976883a1d944da81950003995249d" args="(const goMath::Matrix&lt; T &gt; &amp;simplex, const goMath::Vector&lt; T &gt; &amp;point, goMath::Vector&lt; T &gt; &amp;ret)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::euclideanToBarycentric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>simplex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert euclidean to barycentric coordinates. </p>
<p>This works only for vertices with n+1 points in n dimensions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>Simplex points, one point per column </td></tr>
    <tr><td class="paramname">point</td><td>Point in euclidean coordinates </td></tr>
    <tr><td class="paramname">ret</td><td>On return, contains barycentric coordinates of point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise (also check log). </dd></dl>

</div>
</div>
<a class="anchor" id="ga4695915a5b6160a9c0a5bc92ee61db76"></a><!-- doxytag: member="goSparseMatrix::fillBegin" ref="ga4695915a5b6160a9c0a5bc92ee61db76" args="(int elementCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSparseMatrix::fillBegin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementCount</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begin filling elementCount elements in this matrix. </p>
<p>The actual amount of elements filled in can be lower than elementCount. Do not forget to call <a class="el" href="group__math.html#ga52518eeb9a2a05e244c3adc04a16e383" title="Ends filling the matrix.">fillEnd()</a> when done filling in values.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">elementCount</td><td>Maximum number of elements to be filled in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga52518eeb9a2a05e244c3adc04a16e383"></a><!-- doxytag: member="goSparseMatrix::fillEnd" ref="ga52518eeb9a2a05e244c3adc04a16e383" args="(int sortType=ROW_WISE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void goSparseMatrix::fillEnd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sortMethod</em> = <code>ROW_WISE</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ends filling the matrix. </p>
<p>Ends filling and resizes the internal arrays according to the number of elements filled in. </p>

</div>
</div>
<a class="anchor" id="ga3a0b7de82ad4994c21f296b1d6984020"></a><!-- doxytag: member="goSparseMatrix::fillNext" ref="ga3a0b7de82ad4994c21f296b1d6984020" args="(int row, int col, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int goSparseMatrix::fillNext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills the next element in this matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row of the element </td></tr>
    <tr><td class="paramname">col</td><td>Column of the element </td></tr>
    <tr><td class="paramname">value</td><td>Value of the element</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of elements that can still be filled in after this call. If zero, all subsequent calls to <a class="el" href="group__math.html#ga3a0b7de82ad4994c21f296b1d6984020" title="Fills the next element in this matrix.">fillNext()</a> will not change the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="gab044c522e1313099d520307a7bb28efe"></a><!-- doxytag: member="goMath::forwardDifferences" ref="gab044c522e1313099d520307a7bb28efe" args="(const goSignal3DBase&lt; void &gt; &amp;x, goSignal3DBase&lt; void &gt; &amp;retValue, int dimension=0, goDouble h=1.0, const goSignal3DBase&lt; void &gt; *mask=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::forwardDifferences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>retValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>h</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>mask</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate forward finite differences in a given direction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Data grid. </td></tr>
    <tr><td class="paramname">retValue</td><td>Contains finite differences after the function returns true. If the size of retValue does not match the size of x and retValue is a <a class="el" href="classgoSignal3D.html">goSignal3D&lt;void&gt;</a>, retValue will be resized to the size of x, including number of channels, blocksize of x and border of 1 in each direction. </td></tr>
    <tr><td class="paramname">dimension</td><td>Dimension (0, 1, or 2 for x, y, or z) </td></tr>
    <tr><td class="paramname">h</td><td>Grid spacing (default 1) </td></tr>
    <tr><td class="paramname">mask</td><td>Optional mask of type goInt8. If given, central differences are only calculated where mask is != 0. The other values in retValue are not changed. Default: NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Only goFloat and goDouble data are supported. The data types of x and retValue may differ. Both are given by the user, so the data type of retValue must be set before calling this function. It may be of wrong size, in which case it must point to a <a class="el" href="classgoSignal3D.html">goSignal3D&lt;void&gt;</a> in order for it to be resizable. </dd>
<dd>
The algorithm is run for all channels.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Christian Gosch </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa12bb1fe580f2a6d78b8a1a3cc00af5"></a><!-- doxytag: member="goSparseMatrix::getElementCount" ref="gaaa12bb1fe580f2a6d78b8a1a3cc00af5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int goSparseMatrix::getElementCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total number of nonzero elements. </p>
<p>nnz() in Matlab.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of nonzero elements. </dd></dl>

</div>
</div>
<a class="anchor" id="gae33acfc40a189829345d72d2d5dacf7c"></a><!-- doxytag: member="goMath::goConjugateGradients" ref="gae33acfc40a189829345d72d2d5dacf7c" args="(const MatrixType &amp;A, const VectorType &amp;b, VectorType &amp;x, goDouble epsilon=1e&#45;6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">goDouble goMath::goConjugateGradients </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Conjugate gradients solver. </p>
<p>Conjugate gradients method for solving linear equation systems.</p>
<p>Solves A*x=b iteratively for x.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Currently implemented for <a class="el" href="classgoSparseMatrix.html" title="Basic sparse matrix class with Matlab mxArray support.">goSparseMatrix</a> and <a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">goMath::Vector</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">Matrix</a> A </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">Vector</a> b </td></tr>
    <tr><td class="paramname">x</td><td>Solution </td></tr>
    <tr><td class="paramname">epsilon</td><td>Stop when abs(Ax-b) &lt; epsilon.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>final abs(A*x-b).</dd></dl>
<p>Finde einen Vektor x fuer A*x=b. Geht momentan nur fuer <a class="el" href="classgoSparseMatrix.html" title="Basic sparse matrix class with Matlab mxArray support.">goSparseMatrix</a>. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000063">Todo:</a></b></dt><dd>Spezialimplementierung fuer <a class="el" href="classgoSparseMatrix.html" title="Basic sparse matrix class with Matlab mxArray support.">goSparseMatrix</a> (gibts schon) und Standardimplementierung fuer andere Matrizen.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">Matrix</a> A </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">Vector</a> b </td></tr>
    <tr><td class="paramname">x</td><td>Solution x </td></tr>
    <tr><td class="paramname">epsilon</td><td>Error bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd653cdd30778e71f672cf5c87ea2d35"></a><!-- doxytag: member="goMath::gradient2D" ref="gadd653cdd30778e71f672cf5c87ea2d35" args="(const goSignal3DBase&lt; void &gt; &amp;sig, goSignal3DBase&lt; void &gt; &amp;retValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::gradient2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>retValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the gradient of a 2D signal (z-size == 1). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The data type of the arguments is currently restricted to GO_FLOAT and GO_DOUBLE.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000066">Todo:</a></b></dt><dd>Look at the code and find the reference where this is documented. It's not simply central differences, but rather central differences including the next neighbours.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Contains the 2D signal. </td></tr>
    <tr><td class="paramname">retValue</td><td>After returning true, retValue contains the x and y components of grad(sig). retValue must be of the same size as sig in x and y dimensions and its channel-count must be 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gab40399142d8cd9e3aeb2e5e60e0c3ef3"></a><!-- doxytag: member="goMath::hypot" ref="gab40399142d8cd9e3aeb2e5e60e0c3ef3" args="(const Real &amp;a, const Real &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Real goMath::hypot </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>hypotenuse of real (non-complex) scalars a and b by avoiding underflow/overflow using (a * sqrt( 1 + (b/a) * (b/a))), rather than sqrt(a*a + b*b). </dd></dl>

</div>
</div>
<a class="anchor" id="ga906443556e27c0335fb8db0209fa4f5a"></a><!-- doxytag: member="goMath::integrate" ref="ga906443556e27c0335fb8db0209fa4f5a" args="(const goMath::Vector&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T goMath::integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sehnentrapezformel. Step width (h) is assumed 1, so normalisation may be needed afterwards. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">Vector</a> with function values at equidistant points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Integral approximation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d3b2f36754c98a79b96182a8e68f829"></a><!-- doxytag: member="goMath::integrateSimpson" ref="ga5d3b2f36754c98a79b96182a8e68f829" args="(const goMath::Vector&lt; T &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T goMath::integrateSimpson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integration with Simpson rule. Step width h is assumed 1, so normalisation may be needed afterwards. </p>
<p>The composite Simpson rule is <img class="formulaInl" alt="$ \int_a^b v(t) \, dt \approx \frac{h}{3} \left( v_0 + 2 \cdot \sum\limits_{j=1}^{n/2-1} v_{2j} + 4 \cdot \sum\limits_{j=1}^{n/2} v_{2j-1} + v_n\right) $" src="form_67.png"/>, if the continuous function v(t) is divided into an even number n of equidistant intervals with distance h. Note that <code>integrateSimpson</code> samples linearly between points given in <code>v</code> to obtain an even number of sampled points. Also, only the division by 6 (not 3!) is done, since the step width h is assumed to be one. Normalisation may therefore be done after calling this function by the user, e.g. if the interval [a,b] has length one, by multiplying with 1/v.getSize().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="classgoMath_1_1Vector.html" title="General vector class.">Vector</a> with function values at equidistant points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Integral approximation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga02e7707ad113a5c299a186f914626279"></a><!-- doxytag: member="goMath::karcherMean" ref="ga02e7707ad113a5c299a186f914626279" args="(iterator_type start, int count, manifold_type &amp;manifold, typename manifold_type::Element &amp;meanRet, int max_iterations=1000, double epsilon=1e&#45;6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class iterator_type , class manifold_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::karcherMean </td>
          <td>(</td>
          <td class="paramtype">iterator_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">manifold_type &amp;&#160;</td>
          <td class="paramname"><em>manifold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename manifold_type::Element &amp;&#160;</td>
          <td class="paramname"><em>meanRet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Karcher mean for generic Riemannian manifolds. </p>
<p>The Karcher mean is calculated by iterating using the update step <img class="formulaInl" alt="$ y_{i+1} = \exp_{y_i} \left( \frac{1}{N} \sum_{j=1}^N \log_{y_i} x_j \right) $" src="form_21.png"/> until <code>max_iterations</code> has been reached or until <img class="formulaInl" alt="$ \langle t,t \rangle_{y_i} < \varepsilon $" src="form_22.png"/>, with <img class="formulaInl" alt="$ t = \frac{1}{N} \sum_{j=1}^N \log_{y_i} x_j$" src="form_23.png"/>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start iterator, pointing to the first element x_j. </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements N. </td></tr>
    <tr><td class="paramname">manifold</td><td><a class="el" href="classgoMath_1_1Manifold.html" title="Interface for manifolds.">Manifold</a> object (e.g. <a class="el" href="classgoMath_1_1SO3.html" title="Rotation group.">SO3</a>). </td></tr>
    <tr><td class="paramname">meanRet</td><td>Return value, contains the mean after returning true. </td></tr>
    <tr><td class="paramname">max_iterations</td><td>Max. number of iterations. Default: 1000 </td></tr>
    <tr><td class="paramname">epsilon</td><td>"Small" floating point value. Default: 1e-6</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if mean could be found within max_iterations, false otherwise. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="karchermean_2km_8cpp-example.html#a12">karchermean/km.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga25bf56fbb35cd6837d8c0696b1b8065b"></a><!-- doxytag: member="goMath::laplacian2D" ref="ga25bf56fbb35cd6837d8c0696b1b8065b" args="(const goSignal3DBase&lt; void &gt; &amp;sig, goSignal3DBase&lt; void &gt; &amp;retValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::laplacian2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>retValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the laplacian (2nd derivative) of a 2D signal (z-size == 1). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The data type of the arguments is currently restricted to GO_FLOAT, but GO_DOUBLE will also be implemented. Multichannel data is not yet supported by libGo.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Contains the 2D signal. </td></tr>
    <tr><td class="paramname">retValue</td><td>After returning true, retValue contains the laplace(sig). retValue must be of the same size as sig in x and y dimensions and its z dimension must be 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000065">Todo:</a></b></dt><dd>BUG: This sometimes can produce NaNs.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gacd2a07bfe5dc51bad6d5e46e425ec934"></a><!-- doxytag: member="goSparseMatrix::matrixVectorMult" ref="gacd2a07bfe5dc51bad6d5e46e425ec934" args="(goArray&lt; goDouble &gt; &amp;ret, const goArray&lt; goDouble &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSparseMatrix::matrixVectorMult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(this) * v </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ret</td><td></td></tr>
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga392c79b5192254540d7fc7f9de1840c0"></a><!-- doxytag: member="goSparseMatrix::matrixVectorMult" ref="ga392c79b5192254540d7fc7f9de1840c0" args="(goMath::Vector&lt; Tv &gt; &amp;ret, const goMath::Vector&lt; Tv &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tv &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goSparseMatrix::matrixVectorMult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; Tv &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; Tv &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(this) * v </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ret</td><td></td></tr>
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga03285f3737a34d3bbc0670f0711b2f2d"></a><!-- doxytag: member="goSparseMatrix::matrixVectorMult" ref="ga03285f3737a34d3bbc0670f0711b2f2d" args="(goSparseMatrix &amp;ret, const goArray&lt; goDouble &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSparseMatrix::matrixVectorMult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(this) * v </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ret</td><td></td></tr>
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga17f4a106b834da91b7b404a85a7d3668"></a><!-- doxytag: member="goSparseMatrix::matrixVectorMult" ref="ga17f4a106b834da91b7b404a85a7d3668" args="(goSparseMatrix &amp;ret, const goMath::Vector&lt; Tv &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tv &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goSparseMatrix::matrixVectorMult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; Tv &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(this) * v </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ret</td><td></td></tr>
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gaa3e7b0370f4f4d5be1e682b31341bb84"></a><!-- doxytag: member="goMath::max" ref="gaa3e7b0370f4f4d5be1e682b31341bb84" args="(Scalar a, Scalar b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar goMath::max </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the maximum of scalars a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="ga588f091922b9107a7a34d3c8193be121"></a><!-- doxytag: member="goMath::min" ref="ga588f091922b9107a7a34d3c8193be121" args="(Scalar a, Scalar b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar goMath::min </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum of scalars a and b. </dd></dl>

</div>
</div>
<a class="anchor" id="gac66533de3266bba340fa0eda90b506ef"></a><!-- doxytag: member="goMath::mod" ref="gac66533de3266bba340fa0eda90b506ef" args="(T value, T modulus)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T goMath::mod </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modulus function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">modulus</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>value</code> mod <code>modulus</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga785a0487be36455e9172992f64c90a17"></a><!-- doxytag: member="goMath::paste2D" ref="ga785a0487be36455e9172992f64c90a17" args="(const goSignal3DBase&lt; void &gt; &amp;source, goDouble scale, goDouble angle, goDouble t_x, goDouble t_y, goSignal3DBase&lt; void &gt; &amp;target, goFloat bgColour)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void goMath::paste2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>t_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>t_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goFloat&#160;</td>
          <td class="paramname"><em>bgColour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Paste <code>source</code> at under some euclidean transformations into <code>target</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source patch </td></tr>
    <tr><td class="paramname">scale</td><td>scale factor </td></tr>
    <tr><td class="paramname">angle</td><td>rotation angle </td></tr>
    <tr><td class="paramname">t_x</td><td>Translation x </td></tr>
    <tr><td class="paramname">t_y</td><td>Translation y </td></tr>
    <tr><td class="paramname">target</td><td>target signal (is left unchanged except for the pasted <code>source</code>) </td></tr>
    <tr><td class="paramname">bgColour</td><td>Transparent colour in <code>source</code>. Only points which have different colour values are pasted into <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab7d59c331113599237c2cd4f801e73db"></a><!-- doxytag: member="goMath::resampleCubic" ref="gab7d59c331113599237c2cd4f801e73db" args="(const goMath::Matrix&lt; T &gt; &amp;source, goMath::Matrix&lt; T &gt; &amp;target, goSize_t resamplePointCount, bool closed=false, goFixedArray&lt; goDouble &gt; *accumLength_=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goMath::resampleCubic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gotypes_8h.html#a02284d9088a729cca83dc808dd409e09">goSize_t</a>&#160;</td>
          <td class="paramname"><em>resamplePointCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoFixedArray.html">goFixedArray</a>&lt; goDouble &gt; *&#160;</td>
          <td class="paramname"><em>accumLength_</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Piecewise cubic resampling of a curve represented by a configuration matrix. </p>
<p>The source matrix contains a point in each row, so does the target matrix after successful completion of the function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source points. </td></tr>
    <tr><td class="paramname">target</td><td>Target points. </td></tr>
    <tr><td class="paramname">resamplePointCount</td><td>Point count intended for target. </td></tr>
    <tr><td class="paramname">closed</td><td>If true, the source points will be treated as a closed curve, i.e. the first and last points are connected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga51ff1eaa8f69b4aaa6b07142d1c00c3d"></a><!-- doxytag: member="goMath::scale2D" ref="ga51ff1eaa8f69b4aaa6b07142d1c00c3d" args="(const goSignal3DBase&lt; void &gt; &amp;source, goSignal3DBase&lt; void &gt; &amp;target, bool keep_aspect=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void goMath::scale2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_aspect</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scale <code>source</code> into <code>target</code>. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000086">Todo:</a></b></dt><dd>Extend to 3D -- this only requires to write a 3D sampling function.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Original 2D signal </td></tr>
    <tr><td class="paramname">target</td><td>Target 2D signal </td></tr>
    <tr><td class="paramname">keep_aspect</td><td>If true, keep aspect ratio </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab4dbc2d797d135840fb504509b5410fa"></a><!-- doxytag: member="goSparseMatrix::set" ref="gab4dbc2d797d135840fb504509b5410fa" args="(int row, int col, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void goSparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Not implemented. </p>
<p>A general set function would require some reallocating and copying of arrays. I had no use for that so far, but please implement it <b>AND GIVE IT BACK TO ME</b> if you need it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td></td></tr>
    <tr><td class="paramname">col</td><td></td></tr>
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa7f4aac5015bddc813ff7248a242e4bd"></a><!-- doxytag: member="goSparseMatrix::sortColumns" ref="gaa7f4aac5015bddc813ff7248a242e4bd" args="(bool sort_rows=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void goSparseMatrix::sortColumns </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_rows</em> = <code>false</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts in ascending column order. </p>
<p>Sorts all elements so that they appear in ascending column order in the internal arrays. </p>

</div>
</div>
<a class="anchor" id="ga53e5f8bca9b600f2d05706b52d2e0fff"></a><!-- doxytag: member="goSparseMatrix::sortRows" ref="ga53e5f8bca9b600f2d05706b52d2e0fff" args="(bool sort_columns=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void goSparseMatrix::sortRows </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_columns</em> = <code>false</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts in ascending row order. </p>
<p>Sorts all elements so that they appear in ascending row order in the internal arrays. </p>

</div>
</div>
<a class="anchor" id="ga6a01e8162c28f8c719683e75c0c395bc"></a><!-- doxytag: member="goMath::stencil" ref="ga6a01e8162c28f8c719683e75c0c395bc" args="(const goSignal3DBase&lt; void &gt; &amp;sig, const goMath::Matrix&lt; T &gt; &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T goMath::stencil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoMath_1_1Matrix.html">goMath::Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate <img class="formulaInl" alt="$ \sum_{i,j} sig(i,j,0) \cdot s(i,j) $" src="form_68.png"/>. </p>
<p>Can be used to calculate a sum of a 2D stencil multiplied by the values in <code>sig</code>. Only the z=0 plane is accounted for in <code>sig</code>. You can for example have a <code><a class="el" href="classgoSubSignal3D.html" title="Access to sub-areas of goSignal3DBase objects.">goSubSignal3D</a></code> move over a <code><a class="el" href="classgoSignal3DBase.html" title="Base class for up to 3D signals.">goSignal3DBase</a></code> and calculate some weighted sum (in 2D) at each point of interest.</p>
<p>The sizes of sig and s should match.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal </td></tr>
    <tr><td class="paramname">s</td><td><a class="el" href="classgoMath_1_1Matrix.html" title="Matrix class.">Matrix</a> containing the stencil.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The sum of the elements in <code>sig</code> weighted with <code>s</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3575386b808acff1ac42aabcd0c748f7"></a><!-- doxytag: member="goMath::transform2D" ref="ga3575386b808acff1ac42aabcd0c748f7" args="(const goSignal3DBase&lt; void &gt; &amp;source, goDouble scale, goDouble angle, goDouble t_x, goDouble t_y, goSignal3D&lt; void &gt; &amp;target, bool setsize=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void goMath::transform2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>t_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>t_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3D.html">goSignal3D</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setsize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>2D euclidean transformation of an image. </p>
<p>Calculate <img class="formulaInl" alt="$ target(x) = source(s\cdot\Gamma\cdot x + T) $" src="form_69.png"/></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source image (2D) </td></tr>
    <tr><td class="paramname">scale</td><td>Scale factor </td></tr>
    <tr><td class="paramname">angle</td><td>Rotation angle </td></tr>
    <tr><td class="paramname">t_x</td><td>Translation in x </td></tr>
    <tr><td class="paramname">t_y</td><td>Translation in y </td></tr>
    <tr><td class="paramname">target</td><td>Target, will be resized and set to the data type of <code>source</code> if necessary. </td></tr>
    <tr><td class="paramname">setsize</td><td>Automatically set size of target if it does not fit. Default: true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabfe54e23447b84494a172c12d645c51e"></a><!-- doxytag: member="goSparseMatrix::vectorMatrixMult" ref="gabfe54e23447b84494a172c12d645c51e" args="(goSparseMatrix &amp;ret, const goArray&lt; goDouble &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSparseMatrix::vectorMatrixMult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoSparseMatrix.html">goSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>v' * (this) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ret</td><td></td></tr>
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga79dd3aa87e401b441e4cb7a37674c40c"></a><!-- doxytag: member="goSparseMatrix::vectorMatrixMult" ref="ga79dd3aa87e401b441e4cb7a37674c40c" args="(goArray&lt; goDouble &gt; &amp;ret, const goArray&lt; goDouble &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSparseMatrix::vectorMatrixMult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoArray.html">goArray</a>&lt; goDouble &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>v' * (this) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ret</td><td></td></tr>
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Tue Feb 14 2012 22:16:08 for golib by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
