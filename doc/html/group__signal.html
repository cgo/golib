<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>golib: Data handling for up to 3D data</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">golib
   &#160;<span id="projectnumber">0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__signal.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Data handling for up to 3D data</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoDWT.html">goDWT&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoDWT3D.html">goDWT3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D discrete wavelet transform.  <a href="classgoDWT3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoFilter1D.html">goFilter1D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separable filter for 3D signals.  <a href="classgoFilter1D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoFilter3D.html">goFilter3D&lt; T_IN, T_OUT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D filter class.  <a href="classgoFilter3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoHistogram.html">goHistogram&lt; level_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoCDF.html">goCDF&lt; level_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoQuantizer.html">goQuantizer&lt; _input_type, _output_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantizer base class.  <a href="classgoQuantizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignal3D.html">goSignal3D&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Up to 3-dimensional (signal) data container.  <a href="classgoSignal3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for up to 3D signals.  <a href="classgoSignal3DBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignal3DGenericIterator.html">goSignal3DGenericIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for <a class="el" href="classgoSignal3DBase.html">goSignal3DBase&lt;void&gt;</a> class signals.  <a href="classgoSignal3DGenericIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignal3DGenericIterator2.html">goSignal3DGenericIterator2&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignal3DGenericConstIterator.html">goSignal3DGenericConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignal3DIterator.html">goSignal3DIterator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for goSignal3DBase&lt;T&gt; class signals.  <a href="classgoSignal3DIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignal3DRef.html">goSignal3DRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for any memory area suitable for representation through a <a class="el" href="classgoSignal3DBase.html" title="Base class for up to 3D signals. ">goSignal3DBase</a> type object (e.g. simply linearly stored data)  <a href="classgoSignal3DRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignalOperationGeneric.html">goSignalOperationGeneric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic value-wise operations.  <a href="classgoSignalOperationGeneric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignalOperation3.html">goSignalOperation3&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise operation of two sources into one target.  <a href="classgoSignalOperation3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignalOperation2.html">goSignalOperation2&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise operation of one source into one target.  <a href="classgoSignalOperation2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignalOperation1.html">goSignalOperation1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise in-place operation.  <a href="classgoSignalOperation1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSignalOperation1Const.html">goSignalOperation1Const&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise in-place operation on constant data.  <a href="classgoSignalOperation1Const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoSubSignal3D.html">goSubSignal3D&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to sub-areas of <code><a class="el" href="classgoSignal3DBase.html" title="Base class for up to 3D signals. ">goSignal3DBase</a></code> objects.  <a href="classgoSubSignal3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoUniformQuantizer.html">goUniformQuantizer&lt; _input_type, _output_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform quantizer.  <a href="classgoUniformQuantizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga04caecfa635976c7770cd6abbef10b43"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>SIGNAL3D_bilinear</b>(__A,  __B,  __C,  __D,  __px,  __py,  __target)</td></tr>
<tr class="separator:ga04caecfa635976c7770cd6abbef10b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacde2ef0f0c367ffbc2bc910381e56c1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#gacde2ef0f0c367ffbc2bc910381e56c1f">GO_SIGNAL3D_EACHELEMENT</a>(__dothis,  __signal,  __type)</td></tr>
<tr class="separator:gacde2ef0f0c367ffbc2bc910381e56c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0ef9829a584a377035d98d86236bcc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga5a0ef9829a584a377035d98d86236bcc">GO_SIGNAL3D_EACHELEMENT_GENERIC</a>(__dothis,  __signal)</td></tr>
<tr class="memdesc:ga5a0ef9829a584a377035d98d86236bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">For generic (void type) signals.  <a href="#ga5a0ef9829a584a377035d98d86236bcc">More...</a><br /></td></tr>
<tr class="separator:ga5a0ef9829a584a377035d98d86236bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51d9d5c22b4c12add2dbab7c78bc220"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>GO_SIGNAL3D_EACHELEMENT_GENERIC_CONST</b>(__dothis,  __signal)</td></tr>
<tr class="separator:gae51d9d5c22b4c12add2dbab7c78bc220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b9be36f4585f4660b428f51d1af24a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga9b9be36f4585f4660b428f51d1af24a0">GO_SIGNAL3D_EACHELEMENT_2</a>(__dothis,  __signal,  __signal_target,  __type,  __type_target)</td></tr>
<tr class="separator:ga9b9be36f4585f4660b428f51d1af24a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac74ef9155d3e44c44e53ef6ca8bbe014"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac74ef9155d3e44c44e53ef6ca8bbe014"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GO_SIGNAL3D_EACHELEMENT_2_GENERIC</b>(__dothis,  __signal,  __signal_target)</td></tr>
<tr class="separator:gac74ef9155d3e44c44e53ef6ca8bbe014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae485f1a4defe1c717a6d11847b76e0f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae485f1a4defe1c717a6d11847b76e0f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GO_SIGNAL3D_EACHELEMENT_2_GENERIC_CONST</b>(__dothis,  __signal,  __signal_target)</td></tr>
<tr class="separator:gae485f1a4defe1c717a6d11847b76e0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1151d1fce257f1be51003b2a0ab60143"><td class="memItemLeft" align="right" valign="top">typedef goDouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga1151d1fce257f1be51003b2a0ab60143">godwt_t</a></td></tr>
<tr class="separator:ga1151d1fce257f1be51003b2a0ab60143"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga80533cf87f3c9167728929c2cefbb89e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga80533cf87f3c9167728929c2cefbb89e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>goFileIO::readImage</b> (const char *filename, <a class="el" href="classgoSignal3D.html">goSignal3D</a>&lt; void &gt; *signal, bool linear=false)  throw (goFileIOException, goTypeException)</td></tr>
<tr class="separator:ga80533cf87f3c9167728929c2cefbb89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0302137b866e9f9d451c332d7bb4811a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga0302137b866e9f9d451c332d7bb4811a">goFileIO::writeImage</a> (const char *filename, const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *signal)  throw (goFileIOException, goTypeException)</td></tr>
<tr class="memdesc:ga0302137b866e9f9d451c332d7bb4811a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an image file from a <a class="el" href="classgoSignal3DBase.html">goSignal3DBase&lt;void&gt;</a> object.  <a href="#ga0302137b866e9f9d451c332d7bb4811a">More...</a><br /></td></tr>
<tr class="separator:ga0302137b866e9f9d451c332d7bb4811a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75e2087d605a6d345eec59c637c47765"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga75e2087d605a6d345eec59c637c47765">goNormalizeSignal</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *sig, <a class="el" href="classgoSignal3D.html">goSignal3D</a>&lt; void &gt; *targetSig)</td></tr>
<tr class="memdesc:ga75e2087d605a6d345eec59c637c47765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes or translates a float or double type signal to the interval [0,1].  <a href="#ga75e2087d605a6d345eec59c637c47765">More...</a><br /></td></tr>
<tr class="separator:ga75e2087d605a6d345eec59c637c47765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ce5a51f4f937cca0e88f20f664afde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga21ce5a51f4f937cca0e88f20f664afde">goNormalizeSignal</a> (<a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *sig)</td></tr>
<tr class="memdesc:ga21ce5a51f4f937cca0e88f20f664afde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes or translates a float or double type signal to the interval [0,1].  <a href="#ga21ce5a51f4f937cca0e88f20f664afde">More...</a><br /></td></tr>
<tr class="separator:ga21ce5a51f4f937cca0e88f20f664afde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga549a1cac85fcbd579ac9f43f9f417baa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga549a1cac85fcbd579ac9f43f9f417baa">goFindZeroCrossings</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *sig, <a class="el" href="classgoArray.html">goArray</a>&lt; <a class="el" href="classgoPoint.html">goPointf</a> &gt; &amp;pointsRet)</td></tr>
<tr class="memdesc:ga549a1cac85fcbd579ac9f43f9f417baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find zero crossings in <code>sig</code> and return an array of points.  <a href="#ga549a1cac85fcbd579ac9f43f9f417baa">More...</a><br /></td></tr>
<tr class="separator:ga549a1cac85fcbd579ac9f43f9f417baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a77779dbb5de1b7c5006b1acbaae9ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga0a77779dbb5de1b7c5006b1acbaae9ce">goConvertSignal</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *sig, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *targetSig)</td></tr>
<tr class="memdesc:ga0a77779dbb5de1b7c5006b1acbaae9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a signal to another signal with a given data type.  <a href="#ga0a77779dbb5de1b7c5006b1acbaae9ce">More...</a><br /></td></tr>
<tr class="separator:ga0a77779dbb5de1b7c5006b1acbaae9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb3974e42a6d1a74c276c1a69ea7e3b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#gaeb3974e42a6d1a74c276c1a69ea7e3b8">goCopySignal</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *sig, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *targetSig)</td></tr>
<tr class="memdesc:gaeb3974e42a6d1a74c276c1a69ea7e3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a signal to another signal.  <a href="#gaeb3974e42a6d1a74c276c1a69ea7e3b8">More...</a><br /></td></tr>
<tr class="separator:gaeb3974e42a6d1a74c276c1a69ea7e3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057509ee31c9f7bba8c2d9d70388c528"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga057509ee31c9f7bba8c2d9d70388c528">goCopySignalChannel</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *sig, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *targetSig)</td></tr>
<tr class="memdesc:ga057509ee31c9f7bba8c2d9d70388c528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a channel from a signal to another signal.  <a href="#ga057509ee31c9f7bba8c2d9d70388c528">More...</a><br /></td></tr>
<tr class="separator:ga057509ee31c9f7bba8c2d9d70388c528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1a4700cc3cad7e5e371bd7c58feb4f7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gad1a4700cc3cad7e5e371bd7c58feb4f7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__signal.html#gad1a4700cc3cad7e5e371bd7c58feb4f7">goCopySignalArray</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *sig, T *targetArray, int *strides=0)</td></tr>
<tr class="memdesc:gad1a4700cc3cad7e5e371bd7c58feb4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the signal values to the linear array <code>targetArray</code>.  <a href="#gad1a4700cc3cad7e5e371bd7c58feb4f7">More...</a><br /></td></tr>
<tr class="separator:gad1a4700cc3cad7e5e371bd7c58feb4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db5b7f19dfac01cdb1cea64f46a0e77"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga3db5b7f19dfac01cdb1cea64f46a0e77"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__signal.html#ga3db5b7f19dfac01cdb1cea64f46a0e77">goCopySignalArray</a> (const T *array, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *targetSig, int *strides=0)</td></tr>
<tr class="memdesc:ga3db5b7f19dfac01cdb1cea64f46a0e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the values in a linear array to a signal.  <a href="#ga3db5b7f19dfac01cdb1cea64f46a0e77">More...</a><br /></td></tr>
<tr class="separator:ga3db5b7f19dfac01cdb1cea64f46a0e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga180a107ad82ed41fffba7055c204b12c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga180a107ad82ed41fffba7055c204b12c">goFillSignal</a> (<a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *sig, goFloat value)</td></tr>
<tr class="memdesc:ga180a107ad82ed41fffba7055c204b12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a signal with a float value (will be converted).  <a href="#ga180a107ad82ed41fffba7055c204b12c">More...</a><br /></td></tr>
<tr class="separator:ga180a107ad82ed41fffba7055c204b12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70917bd90ac12b35335114bb6983456e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga70917bd90ac12b35335114bb6983456e">goRGBAtoScalar</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *sig, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *targetSig)</td></tr>
<tr class="memdesc:ga70917bd90ac12b35335114bb6983456e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an RGBA 3- or 4-channel signal to a scalar 1-channel signal.  <a href="#ga70917bd90ac12b35335114bb6983456e">More...</a><br /></td></tr>
<tr class="separator:ga70917bd90ac12b35335114bb6983456e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga193ecc6e5d8528ba458ccd4bc0c8b88e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga193ecc6e5d8528ba458ccd4bc0c8b88e">goSignalInfoText</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, <a class="el" href="classgoString.html">goString</a> &amp;strRet, bool html=false)</td></tr>
<tr class="memdesc:ga193ecc6e5d8528ba458ccd4bc0c8b88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get some description (as ASCII text) for a signal.  <a href="#ga193ecc6e5d8528ba458ccd4bc0c8b88e">More...</a><br /></td></tr>
<tr class="separator:ga193ecc6e5d8528ba458ccd4bc0c8b88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d1a4bf4448a6791077230d43621bc8"><td class="memItemLeft" align="right" valign="top">goDouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga91d1a4bf4448a6791077230d43621bc8">goSignalMean</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig)</td></tr>
<tr class="memdesc:ga91d1a4bf4448a6791077230d43621bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the signal mean.  <a href="#ga91d1a4bf4448a6791077230d43621bc8">More...</a><br /></td></tr>
<tr class="separator:ga91d1a4bf4448a6791077230d43621bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977f1b8a907e54de42104f76978de9fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga977f1b8a907e54de42104f76978de9fb">goSignalMeanVariance</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, goDouble &amp;mean, goDouble &amp;variance)</td></tr>
<tr class="memdesc:ga977f1b8a907e54de42104f76978de9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate mean and variance of a signal.  <a href="#ga977f1b8a907e54de42104f76978de9fb">More...</a><br /></td></tr>
<tr class="separator:ga977f1b8a907e54de42104f76978de9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed7d31e0fb129fcc92fa1e4c178c2c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#gabed7d31e0fb129fcc92fa1e4c178c2c6">goSignalFlipY</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;target)</td></tr>
<tr class="memdesc:gabed7d31e0fb129fcc92fa1e4c178c2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the signal data in Y direction.  <a href="#gabed7d31e0fb129fcc92fa1e4c178c2c6">More...</a><br /></td></tr>
<tr class="separator:gabed7d31e0fb129fcc92fa1e4c178c2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga670c375469ade66a12a2b2895f0f2b33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga670c375469ade66a12a2b2895f0f2b33">goSignalCOM</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, <a class="el" href="classgoMath_1_1Vector.html">goMath::Vectord</a> &amp;comRet)</td></tr>
<tr class="memdesc:ga670c375469ade66a12a2b2895f0f2b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate centre of mass of <code>sig</code>.  <a href="#ga670c375469ade66a12a2b2895f0f2b33">More...</a><br /></td></tr>
<tr class="separator:ga670c375469ade66a12a2b2895f0f2b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d59cd91d4322a02939d5dc516b1b4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#gaf7d59cd91d4322a02939d5dc516b1b4e">goSignalMinMaxCoord</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, goDouble thresh, <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> &gt; &amp;minRet, <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> &gt; &amp;maxRet)</td></tr>
<tr class="memdesc:gaf7d59cd91d4322a02939d5dc516b1b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find min and max coordinates in <code>sig</code> where the value is below <code>thresh</code>.  <a href="#gaf7d59cd91d4322a02939d5dc516b1b4e">More...</a><br /></td></tr>
<tr class="separator:gaf7d59cd91d4322a02939d5dc516b1b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924ff3480d77147839f75f592841b8c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga924ff3480d77147839f75f592841b8c9">goSignalMinMaxCoord</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, <a class="el" href="classgoAutoPtr.html">goAutoPtr</a>&lt; <a class="el" href="classgoFunctorBase1.html">goFunctorBase1</a>&lt; bool, goDouble &gt; &gt; f, <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> &gt; &amp;minRet, <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> &gt; &amp;maxRet)</td></tr>
<tr class="memdesc:ga924ff3480d77147839f75f592841b8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic ROI finding. Find min and max coordinates in <code>sig</code> where <code>f</code>(<code>value</code>) is <code>true</code>.  <a href="#ga924ff3480d77147839f75f592841b8c9">More...</a><br /></td></tr>
<tr class="separator:ga924ff3480d77147839f75f592841b8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c248b32b3886ebe6d417ac93f9df6f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga2c248b32b3886ebe6d417ac93f9df6f5">goSignalMinMaxCoordHigher</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, goDouble thresh, <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> &gt; &amp;minRet, <a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> &gt; &amp;maxRet)</td></tr>
<tr class="memdesc:ga2c248b32b3886ebe6d417ac93f9df6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="group__signal.html#gaf7d59cd91d4322a02939d5dc516b1b4e" title="Find min and max coordinates in sig where the value is below thresh. ">goSignalMinMaxCoord()</a>, but finds a light border.  <a href="#ga2c248b32b3886ebe6d417ac93f9df6f5">More...</a><br /></td></tr>
<tr class="separator:ga2c248b32b3886ebe6d417ac93f9df6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga151d40f9ade6b864ea8e59a4262bc31a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga151d40f9ade6b864ea8e59a4262bc31a">goSignalCrop</a> (<a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, <a class="el" href="classgoSubSignal3D.html">goSubSignal3D</a>&lt; void &gt; &amp;target, goDouble thresh)</td></tr>
<tr class="memdesc:ga151d40f9ade6b864ea8e59a4262bc31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crop dark or empty borders from <code>sig</code>.  <a href="#ga151d40f9ade6b864ea8e59a4262bc31a">More...</a><br /></td></tr>
<tr class="separator:ga151d40f9ade6b864ea8e59a4262bc31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49aad7d4d9943a07eb2b6db4add7958"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#gae49aad7d4d9943a07eb2b6db4add7958">goSignalCrop</a> (<a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, <a class="el" href="classgoSubSignal3D.html">goSubSignal3D</a>&lt; void &gt; &amp;target, <a class="el" href="classgoAutoPtr.html">goAutoPtr</a>&lt; <a class="el" href="classgoFunctorBase1.html">goFunctorBase1</a>&lt; bool, goDouble &gt; &gt; f)</td></tr>
<tr class="memdesc:gae49aad7d4d9943a07eb2b6db4add7958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic image cropping.  <a href="#gae49aad7d4d9943a07eb2b6db4add7958">More...</a><br /></td></tr>
<tr class="separator:gae49aad7d4d9943a07eb2b6db4add7958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62025632ec8545006cad80d863d99b34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#ga62025632ec8545006cad80d863d99b34">goSignalCropHigher</a> (<a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, <a class="el" href="classgoSubSignal3D.html">goSubSignal3D</a>&lt; void &gt; &amp;target, goDouble thresh)</td></tr>
<tr class="memdesc:ga62025632ec8545006cad80d863d99b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="group__signal.html#ga151d40f9ade6b864ea8e59a4262bc31a" title="Crop dark or empty borders from sig. ">goSignalCrop()</a>, but crops light border.  <a href="#ga62025632ec8545006cad80d863d99b34">More...</a><br /></td></tr>
<tr class="separator:ga62025632ec8545006cad80d863d99b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga102e0c67aaa0760a4072237964a183b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga102e0c67aaa0760a4072237964a183b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>goSignalMax</b> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig1, const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig2, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;target)</td></tr>
<tr class="separator:ga102e0c67aaa0760a4072237964a183b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8372560b328996472c403a03fb8182c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa8372560b328996472c403a03fb8182c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>goSignalMin</b> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig1, const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig2, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;target)</td></tr>
<tr class="separator:gaa8372560b328996472c403a03fb8182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaf88a8471d788a7b991f4c5368e94b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacaf88a8471d788a7b991f4c5368e94b9"></a>
const <a class="el" href="classgo3Vector.html">goSize3D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>goSignal::defaultBlockSize3D</b> ()</td></tr>
<tr class="separator:gacaf88a8471d788a7b991f4c5368e94b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c4487ce65843f2aedaa6808dd62c6bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0c4487ce65843f2aedaa6808dd62c6bc"></a>
const <a class="el" href="classgo3Vector.html">goSize3D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>goSignal::defaultBlockSize2D</b> ()</td></tr>
<tr class="separator:ga0c4487ce65843f2aedaa6808dd62c6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd76ccf427584f3d1afe61ca9daa2be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html#gaedd76ccf427584f3d1afe61ca9daa2be">goSignal::canny</a> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;image, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;ret, goDouble thresh1, goDouble thresh2)</td></tr>
<tr class="memdesc:gaedd76ccf427584f3d1afe61ca9daa2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canny edge detector for 2D images.  <a href="group__signal.html#gaedd76ccf427584f3d1afe61ca9daa2be">More...</a><br /></td></tr>
<tr class="separator:gaedd76ccf427584f3d1afe61ca9daa2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a8ca4fa24a35befbd4df2c76cf7d9ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2a8ca4fa24a35befbd4df2c76cf7d9ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>goSignal::smooth</b> (<a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;sig, <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> width=3)</td></tr>
<tr class="separator:ga2a8ca4fa24a35befbd4df2c76cf7d9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29264276700aba20a78911ce6e0fa7d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29264276700aba20a78911ce6e0fa7d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>goSignal::convert</b> (const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;source, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;target, const int *source_chan, const int *target_chan, int channelCount)</td></tr>
<tr class="separator:ga29264276700aba20a78911ce6e0fa7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd738b9467c2b85f579a853b72169e4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacd738b9467c2b85f579a853b72169e4c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>goSignal::RGB2BGRA</b> (<a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;source, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;target)</td></tr>
<tr class="separator:gacd738b9467c2b85f579a853b72169e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74c1de96578ac972ab9d3037d179f27b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga74c1de96578ac972ab9d3037d179f27b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>goSignal::toBGRA</b> (<a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;source, <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;target, goFloat alpha=-1.0)</td></tr>
<tr class="separator:ga74c1de96578ac972ab9d3037d179f27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa87e0cfb5c2bb4695f4fee55d89d31a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa87e0cfb5c2bb4695f4fee55d89d31a4"></a>
<a class="el" href="classgoAutoPtr.html">goAutoPtr</a>&lt; <a class="el" href="classgoSignal3D.html">goSignal3D</a>&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>goSignal::toBGRA</b> (<a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;source, goFloat alpha=-1.0)</td></tr>
<tr class="separator:gaa87e0cfb5c2bb4695f4fee55d89d31a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="signal-intro"></a>
Introduction</h1>
<p>Golib provides a few classes for handling data storage and access of data arranged in an up to 3-dimensional regular grid. Data can be stored in <a class="el" href="classgoSignal3D.html" title="Up to 3-dimensional (signal) data container. ">goSignal3D</a> objects and be accessed through the base class <a class="el" href="classgoSignal3DBase.html" title="Base class for up to 3D signals. ">goSignal3DBase</a> or through <a class="el" href="classgoSubSignal3D.html" title="Access to sub-areas of goSignal3DBase objects. ">goSubSignal3D</a>, which provides access to rectilinear sub-regions of a <a class="el" href="classgoSignal3DBase.html" title="Base class for up to 3D signals. ">goSignal3DBase</a>. All classes are provided as templates and there are instantiations for the most important simple scalar data types, but it is recommended to use the &lt;void&gt; template parameter and use the (newer) generic interface to the data. The special instantiations do work, but will be deprecated some time in the future and new features will be provided for the &lt;void&gt; instantiations. For those, the data type of the stored data is managed by the class itself. This makes the signal classes more flexible to use and takes away the necessity for functions and classes that use the signal classes also to be templates (which can be a pain).</p>
<h1><a class="anchor" id="signal-orga"></a>
Organisation</h1>
<p><a class="el" href="classgoSignal3DBase.html" title="Base class for up to 3D signals. ">goSignal3DBase</a> is the base class for all signal classes. All data is organised as a rectilinear grid of up to 3 dimensions. The memory is allocated following the concept of data locality by allocating the data in blocks the size of which can be adjusted by the user. This allows for speed-up of code which accesses local neighbourhoods of data points by providing block sizes which enable efficient use of cache structures of the used processor architecture (which naturally is machine dependent). Of cource, by choosing the block size accordingly, data can also be organised linearly. A mechanism allowing to provide borders for a signal is also provided, making it easier to use algorithms which rely on certain assumptions on the border, e.g. that a signal is periodic or that the border is constant.<br />
 <a class="el" href="classgoSignal3D.html" title="Up to 3-dimensional (signal) data container. ">goSignal3D</a> is the class that actually allocates memory and stores data.<br />
 <a class="el" href="classgoSubSignal3D.html" title="Access to sub-areas of goSignal3DBase objects. ">goSubSignal3D</a> can be used to get a window or region of interest from another <a class="el" href="classgoSignal3DBase.html" title="Base class for up to 3D signals. ">goSignal3DBase</a>.</p>
<h1><a class="anchor" id="signal-usage"></a>
Usage</h1>
<h2><a class="anchor" id="usage-general"></a>
General Usage And Iterators</h2>
<p>Using the signal classes is quite simple once you get used to the fact the data is not linear in memory in general. In the simplest case, data can be accessed by the goSignal3DBase::getPtr() methods. However, this is quite slow if you want to go through a lot of points and not just, say, 10 out of a 1024^3 cube. If you want to iterate over all data points, you can make use of <a class="el" href="classgoSignal3DGenericIterator.html" title="Iterator for goSignal3DBase&lt;void&gt; class signals. ">goSignal3DGenericIterator</a> and <a class="el" href="classgoSignal3DGenericConstIterator.html">goSignal3DGenericConstIterator</a>: </p><pre>
  <code>
     <a class="el" href="classgoSignal3D.html">goSignal3D&lt;void&gt;</a> mySignal;
     ... // fill the signal, load data, whatever.
     <a class="el" href="classgoSignal3DGenericIterator.html" title="Iterator for goSignal3DBase&lt;void&gt; class signals. ">goSignal3DGenericIterator</a> it(&amp;mySignal);
     while(!it.endZ())
     {
         it.resetY();
         while (!it.endY())
         {
             it.resetX();
             while (!it.endX())
             {
                 *(goFloat*)*it = calculate_something();
                 it.incrementX();
             }
             it.incrementY();
         } 
         it.incrementZ();
     }
   </code>
 </pre><p> The end[X|Y|Z]() methods indicate the end of one of the three dimensions. You can think of the resetX(), resetY(), resetZ() methods as carriage returns for each dimension. The increment methods of course increment the iterator in one dimension. Note that after this loop, you have to resetZ() the iterator in order to be able to use it again in the same manner, since it reached the end of the Z dimension. Also note that if you have multi-channel signals, you must choose the active channel using setChannel() BEFORE initialising (i.e. creating) the iterator.</p>
<h2><a class="anchor" id="usage-multichannel"></a>
Multiple Channels</h2>
<p>Signals can hold multi-channel data which can be accessed by selecting an active channel with setChannel(). The number of channels can be retrieved with getChannelCount(). Note that the channel data is stored linearly at a point, so by getting the pointer to the 0th channel with the dereference operator of an iterator, you can access the other channels simply by adding the respective value to the pointer. I expect that I will keep this data organisation in the future, so go ahead and use it. But keep in mind that this means using some sort of internal knowledge about the signal storage, which should be avoided in general because of course it is not completely impossible that something is changed about this in the future (however unlikely). However, I think in this case it can mean significant speed-ups.</p>
<p>Reads a PGM (8 bit raw) file into the signal. Signal is newly created. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Fix readPGM etc. for signal3d </dd></dl>
<p>Writes the signal as 8 bit raw PGM file. The signal should contain only values up to 255, since the values are simply casted to goInt8. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gacde2ef0f0c367ffbc2bc910381e56c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GO_SIGNAL3D_EACHELEMENT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__dothis, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__signal, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{   \</div><div class="line">  __type *__ptr_z       = __signal.getPtr(0, 0, 0);         \</div><div class="line">  __type *__ptr;                        \</div><div class="line">  __type *__ptr_y;                      \</div><div class="line">  const goPtrdiff_t* __dx   = __signal.getXDiff();          \</div><div class="line">  const goPtrdiff_t* __dy   = __signal.getYDiff();          \</div><div class="line">  const goPtrdiff_t* __dz   = __signal.getZDiff();          \</div><div class="line">  goSize_t __i,__j,__k;                     \</div><div class="line">  \</div><div class="line">  for (__i = 0; __i &lt; __signal.getSizeZ(); __i++)       \</div><div class="line">    {                               \</div><div class="line">      __ptr_y = __ptr_z;                    \</div><div class="line">      for (__j = 0; __j &lt; __signal.getSizeY(); __j++)       \</div><div class="line">    {                           \</div><div class="line">      __ptr = __ptr_y;                  \</div><div class="line">      for (__k = 0; __k &lt; __signal.getSizeX(); __k++)   \</div><div class="line">        {                           \</div><div class="line">          {                         \</div><div class="line">            __dothis;                   \</div><div class="line">            __ptr += __dx[__k];                 \</div><div class="line">          }                         \</div><div class="line">        }                           \</div><div class="line">      __ptr_y += __dy[__j];                 \</div><div class="line">    }                           \</div><div class="line">      __ptr_z += __dz[__i];                     \</div><div class="line">    }                               \</div><div class="line">                                \</div><div class="line">}</div></div><!-- fragment --><p>Executes <code>__dothis</code> for each element in the <code><a class="el" href="classgoSignal3D.html" title="Up to 3-dimensional (signal) data container. ">goSignal3D</a></code> <code>__signal</code> of type <code>__type</code>. <br />
 The signal is went through using the pointer differences provided by <code><a class="el" href="classgoSignal3D.html" title="Up to 3-dimensional (signal) data container. ">goSignal3D</a></code>. </p><dl class="section author"><dt>Author</dt><dd>Christian Gosch </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b9be36f4585f4660b428f51d1af24a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GO_SIGNAL3D_EACHELEMENT_2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__dothis, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__signal, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__signal_target, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__type_target&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does the same as <code>GO_SIGNAL3D_EACHELEMENT</code> but provides walking through 2 signals of the same size. That can be used to store the results in a second signal. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dwt_8cc-example.html#a7">dwt.cc</a>, and <a class="el" href="filter3d_8cc-example.html#a3">filter3d.cc</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga5a0ef9829a584a377035d98d86236bcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GO_SIGNAL3D_EACHELEMENT_GENERIC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__dothis, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__signal&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For generic (void type) signals. </p>
<p>__dothis will be executed for each signal sample. The pointer __ptr is a pointer to the first <b>byte</b> of the current sample. Cast to an appropriate pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__dothis</td><td>Code to be executed in the inner loop. </td></tr>
    <tr><td class="paramname">__signal</td><td>Signal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae51d9d5c22b4c12add2dbab7c78bc220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GO_SIGNAL3D_EACHELEMENT_GENERIC_CONST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__dothis, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__signal&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{   \</div><div class="line">  const goUInt8 *__ptr_z        = (<span class="keyword">const</span> goUInt8*)__signal.getPtr(0, 0, 0);         \</div><div class="line">  const goUInt8 *__ptr;                     \</div><div class="line">  const goUInt8 *__ptr_y;                       \</div><div class="line">  const goPtrdiff_t* __dx   = __signal.getXDiff();          \</div><div class="line">  const goPtrdiff_t* __dy   = __signal.getYDiff();          \</div><div class="line">  const goPtrdiff_t* __dz   = __signal.getZDiff();          \</div><div class="line">  goSize_t __i,__j,__k;                     \</div><div class="line">  \</div><div class="line">  for (__i = 0; __i &lt; __signal.getSizeZ(); __i++)       \</div><div class="line">    {                               \</div><div class="line">      __ptr_y = __ptr_z;                    \</div><div class="line">      for (__j = 0; __j &lt; __signal.getSizeY(); __j++)       \</div><div class="line">    {                           \</div><div class="line">      __ptr = __ptr_y;                  \</div><div class="line">      for (__k = 0; __k &lt; __signal.getSizeX(); __k++)   \</div><div class="line">        {                           \</div><div class="line">          {                         \</div><div class="line">            __dothis;                   \</div><div class="line">            __ptr += __dx[__k];                 \</div><div class="line">          }                         \</div><div class="line">        }                           \</div><div class="line">      __ptr_y += __dy[__j];                 \</div><div class="line">    }                           \</div><div class="line">      __ptr_z += __dz[__i];                     \</div><div class="line">    }                               \</div><div class="line">                                \</div><div class="line">}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga04caecfa635976c7770cd6abbef10b43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGNAL3D_bilinear</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__A, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__B, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__C, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__D, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__px, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__py, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__target&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{  \</div><div class="line">    goFloat __p1 = __A + ((__B - __A)*__px);                \</div><div class="line">    goFloat __p2 = __C + ((__D - __C)*__px);                \</div><div class="line">    __target =  (__p1 + ((__p2 - __p1)*__py));              \</div><div class="line">}</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga1151d1fce257f1be51003b2a0ab60143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef goDouble <a class="el" href="group__signal.html#ga1151d1fce257f1be51003b2a0ab60143">godwt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for transformed data. Using goDouble for this takes double the amount of memory than goFloat. The goDouble Haar transforms are about 18 percent slower than the goFloat operations. There is, however, a loss in precision when using goFloat. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaedd76ccf427584f3d1afe61ca9daa2be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSignal::canny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>thresh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>thresh2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canny edge detector for 2D images. </p>
<p>Compute the edge map after Canny. The detector consists of 3 steps: First, a Sobel operator is run on the image to find gradient directions and magnitudes. If the image is a colour image (in RGB(A)), it will be converted to a scalar gray value image first. Second, non-maximum suppression is used to thin out the result of the Sobel operator. Third, a hysteresis thresholding is used to reduce the edge map to prominent edgels. Here, <code>thresh1</code> is the high threshold, and <code>thresh2</code> is the low threshold. That means that first, only the responses higher than <code>thresh1</code> are marked as edgels, and then neighbouring responses higher than <code>thresh2</code> are added successively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image </td></tr>
    <tr><td class="paramname">ret</td><td>Return value, contains the edge map on successful return. Must be properly sized or must be a <a class="el" href="classgoSignal3D.html">goSignal3D&lt;void&gt;</a>. If in the latter case it is not of matching size, it will be resized and the type will be set to GO_UINT8. </td></tr>
    <tr><td class="paramname">thresh1</td><td>High threshold for hysteresis (default 80.0) </td></tr>
    <tr><td class="paramname">thresh2</td><td>Low threshold for hysteresis (default 40.0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True is successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a77779dbb5de1b7c5006b1acbaae9ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goConvertSignal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>targetSig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a signal to another signal with a given data type. </p>
<p>The signal sig will be converted if possible to targetSig. The target data type is determined by the data type of targetSig. (set with targetSig-&gt;setDataType()). The size of the target signal must be the same as the source signal. The signals should only differ in their data types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Pointer to the signal to convert. </td></tr>
    <tr><td class="paramname">targetSig</td><td>Pointer to the target signal. The size must be the same as sig.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb3974e42a6d1a74c276c1a69ea7e3b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goCopySignal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>targetSig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a signal to another signal. </p>
<p>The signals do not have to have the same data type. The size is not checked, but each dimension is only copied until the smallest size is reached. Same holds for channels. All channels are copied until one of the signals runs out of channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to copy. </td></tr>
    <tr><td class="paramname">targetSig</td><td>Signal to hold the target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gad1a4700cc3cad7e5e371bd7c58feb4f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goCopySignalArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>targetArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the signal values to the linear array <code>targetArray</code>. </p>
<p>The values will be copied in the order X, then Y, then Z.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to copy. </td></tr>
    <tr><td class="paramname">targetArray</td><td>Linear target array. </td></tr>
    <tr><td class="paramname">strides</td><td>For each dimension, the stride to take in <code>array</code>, in number of elements. May be null, in that case <code>array</code> is assumed to simply linear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3db5b7f19dfac01cdb1cea64f46a0e77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool goCopySignalArray </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>targetSig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the values in a linear array to a signal. </p>
<p>The size of <code>targetSig</code> must be pre-set and it must be allocated ( e.g. with <code>make()</code> ).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array containing values. </td></tr>
    <tr><td class="paramname">targetSig</td><td>Target signal. </td></tr>
    <tr><td class="paramname">strides</td><td>For each dimension, the stride to take in <code>array</code>, in number of elements. May be null, in that case <code>array</code> is assumed to simply linear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga057509ee31c9f7bba8c2d9d70388c528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goCopySignalChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>targetSig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a channel from a signal to another signal. </p>
<p>The signals do not have to have the same data type. The size is not checked, but each dimension is only copied until the smallest size is reached. The currently active channel from sig is copied to the currently active channel of targetSig.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to copy. </td></tr>
    <tr><td class="paramname">targetSig</td><td>Signal to hold the target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="videocapture_2videocapture_8cpp-example.html#a24">videocapture/videocapture.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga180a107ad82ed41fffba7055c204b12c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goFillSignal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goFloat&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a signal with a float value (will be converted). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to fill. </td></tr>
    <tr><td class="paramname">value</td><td>Float value. This value will be converted to an appropriate data type for the signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga549a1cac85fcbd579ac9f43f9f417baa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goFindZeroCrossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoArray.html">goArray</a>&lt; <a class="el" href="classgoPoint.html">goPointf</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointsRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find zero crossings in <code>sig</code> and return an array of points. </p>
<p>On returning true, <code>pointsRet</code> will contain the point coordinates of zero crossings on the grid lines of <code>sig</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to search in. </td></tr>
    <tr><td class="paramname">pointsRet</td><td>Points array (return value).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75e2087d605a6d345eec59c637c47765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goNormalizeSignal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3D.html">goSignal3D</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>targetSig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes or translates a float or double type signal to the interval [0,1]. </p>
<p>If the signal values are out of the interval [0,1], the signal is normalized to it. If (maxValue - minValue) &lt;= 1.0, the signal values are just translated into [0,1]. This function works only on the currently selected channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to be normalized. </td></tr>
    <tr><td class="paramname">targetSig</td><td>Target containing the normalized signal after the call. Note that targetSig is reallocated during the call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise (e.g. if the signal is not float or double). </dd></dl>

</div>
</div>
<a class="anchor" id="ga21ce5a51f4f937cca0e88f20f664afde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goNormalizeSignal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes or translates a float or double type signal to the interval [0,1]. </p>
<dl class="section note"><dt>Note</dt><dd>This does only work on the currently active channel.</dd></dl>
<p>If the signal values are out of the interval [0,1], the signal is normalized to it. If (maxValue - minValue) &lt;= 1.0, the signal values are just translated into [0,1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to be normalized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise (e.g. if the signal is not float or double). </dd></dl>

</div>
</div>
<a class="anchor" id="ga70917bd90ac12b35335114bb6983456e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goRGBAtoScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>targetSig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an RGBA 3- or 4-channel signal to a scalar 1-channel signal. </p>
<p>The source signal must have 3 or 4 channels that are interpreted as RGB(A). The alpha channel is currently not taken into account. The conversion is to luminance after ITU CCR 601:<br />
 Y = 0.299 * R + 0.587 * G + 0.114 * B</p>
<dl class="section note"><dt>Note</dt><dd>The target signal used to be normalised for GO_FLOAT and GO_DOUBLE types. This is no longer the case.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Source signal, must be of type GO_UINT8 and have &gt;= 3 channels. </td></tr>
    <tr><td class="paramname">targetSig</td><td>Target signal. Data type must be set and the size must be the same as that of the source signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga670c375469ade66a12a2b2895f0f2b33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSignalCOM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Vector.html">goMath::Vectord</a> &amp;&#160;</td>
          <td class="paramname"><em>comRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate centre of mass of <code>sig</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Data. </td></tr>
    <tr><td class="paramname">comRet</td><td>On returning true, contains the centre of mass.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga151d40f9ade6b864ea8e59a4262bc31a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSignalCrop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSubSignal3D.html">goSubSignal3D</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crop dark or empty borders from <code>sig</code>. </p>
<p>Uses <a class="el" href="group__signal.html#gaf7d59cd91d4322a02939d5dc516b1b4e" title="Find min and max coordinates in sig where the value is below thresh. ">goSignalMinMaxCoord()</a> to find a region which contains all values &gt;= <code>thresh</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to crop. </td></tr>
    <tr><td class="paramname">target</td><td>On success, is a subsignal of <code>sig</code> representing the region of interest. </td></tr>
    <tr><td class="paramname">thresh</td><td>Threshold.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gae49aad7d4d9943a07eb2b6db4add7958"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSignalCrop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSubSignal3D.html">goSubSignal3D</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoAutoPtr.html">goAutoPtr</a>&lt; <a class="el" href="classgoFunctorBase1.html">goFunctorBase1</a>&lt; bool, goDouble &gt; &gt;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic image cropping. </p>
<p>Given a function <code>f</code>, works like the other <a class="el" href="group__signal.html#ga151d40f9ade6b864ea8e59a4262bc31a" title="Crop dark or empty borders from sig. ">goSignalCrop()</a> function but the border is sought using <code>f</code>. Instead of testing for <code>value</code> &gt;= <code>thresh</code>, <code>f</code>(<code>value</code>) == <code>true</code> is tested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to crop. </td></tr>
    <tr><td class="paramname">target</td><td>On success, is a sub signal of <code>sig</code>. </td></tr>
    <tr><td class="paramname">f</td><td>Functor taking a goDouble and returning a <code>bool</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62025632ec8545006cad80d863d99b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSignalCropHigher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSubSignal3D.html">goSubSignal3D</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="group__signal.html#ga151d40f9ade6b864ea8e59a4262bc31a" title="Crop dark or empty borders from sig. ">goSignalCrop()</a>, but crops light border. </p>
<p>Crops the borders where value &gt;= thresh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to crop. </td></tr>
    <tr><td class="paramname">target</td><td>On success, is a sub signal to <code>sig</code> (the cropped region). </td></tr>
    <tr><td class="paramname">thresh</td><td>Threshold.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gabed7d31e0fb129fcc92fa1e4c178c2c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void goSignalFlipY </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flip the signal data in Y direction. </p>
<p>This does a deep copy. The actual flip() method for <a class="el" href="classgoSignal3DBase.html" title="Base class for up to 3D signals. ">goSignal3DBase</a> is defunct, so this was written as a hack to be able to flip images conveniently. It is, however, slow due to the copy procedure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Original signal. </td></tr>
    <tr><td class="paramname">target</td><td>Target, contains the flipped <code>sig</code> after return. <code>target</code> must be the same size as <code>sig</code>, or nothing will be copied (check log file). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga193ecc6e5d8528ba458ccd4bc0c8b88e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void goSignalInfoText </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoString.html">goString</a> &amp;&#160;</td>
          <td class="paramname"><em>strRet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>html</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get some description (as ASCII text) for a signal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to get the description for. </td></tr>
    <tr><td class="paramname">strRet</td><td>String to hold the description. </td></tr>
    <tr><td class="paramname">html</td><td>If true, the text will be HTML formatted, if false, the text will be plain ASCII. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga91d1a4bf4448a6791077230d43621bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">goDouble goSignalMean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the signal mean. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal to calculate the mean of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mean value as goDouble. For multichannel signals, just do setChannel() and then <a class="el" href="group__signal.html#ga91d1a4bf4448a6791077230d43621bc8" title="Calculate the signal mean. ">goSignalMean()</a> for each channel. </dd></dl>

</div>
</div>
<a class="anchor" id="ga977f1b8a907e54de42104f76978de9fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void goSignalMeanVariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble &amp;&#160;</td>
          <td class="paramname"><em>variance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate mean and variance of a signal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal. </td></tr>
    <tr><td class="paramname">mean</td><td>After returning, holds the mean value as double. </td></tr>
    <tr><td class="paramname">variance</td><td>After returning, holds the variance as double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7d59cd91d4322a02939d5dc516b1b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSignalMinMaxCoord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>minRet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find min and max coordinates in <code>sig</code> where the value is below <code>thresh</code>. </p>
<p>This gets e.g. used in <a class="el" href="group__signal.html#ga151d40f9ade6b864ea8e59a4262bc31a" title="Crop dark or empty borders from sig. ">goSignalCrop()</a>. It finds the rectangular region of interest which contains all values larger than <code>thresh</code>. Good for example to crop dark borders from images or simply "empty space".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal. </td></tr>
    <tr><td class="paramname">thresh</td><td>Threshold. </td></tr>
    <tr><td class="paramname">minRet</td><td>On success, contains the minimum coordinates of the rectangular region of interest with values larger than <code>thresh</code>. </td></tr>
    <tr><td class="paramname">maxRet</td><td>On success, contains the maximum coordinates of the rectangular region of interest with values larger than <code>thresh</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga924ff3480d77147839f75f592841b8c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSignalMinMaxCoord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoAutoPtr.html">goAutoPtr</a>&lt; <a class="el" href="classgoFunctorBase1.html">goFunctorBase1</a>&lt; bool, goDouble &gt; &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>minRet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic ROI finding. Find min and max coordinates in <code>sig</code> where <code>f</code>(<code>value</code>) is <code>true</code>. </p>
<p>Given a function <code>f</code>, works like the other <a class="el" href="group__signal.html#ga151d40f9ade6b864ea8e59a4262bc31a" title="Crop dark or empty borders from sig. ">goSignalCrop()</a> function but the border is sought using <code>f</code>. Instead of testing for <code>value</code> &gt;= <code>thresh</code>, <code>f</code>(<code>value</code>) == <code>true</code> is tested.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__signal.html#gaf7d59cd91d4322a02939d5dc516b1b4e" title="Find min and max coordinates in sig where the value is below thresh. ">goSignalMinMaxCoord()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal. </td></tr>
    <tr><td class="paramname">f</td><td>Pointer to a functor returning bool, taking one goDouble as argument. </td></tr>
    <tr><td class="paramname">minRet</td><td>On success, contains the minimum coordinates of the rectangular region of interest with values for which f() is true. </td></tr>
    <tr><td class="paramname">maxRet</td><td>On success, contains the maximum coordinates of the rectangular region of interest with values for which f() is true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c248b32b3886ebe6d417ac93f9df6f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool goSignalMinMaxCoordHigher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">goDouble&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>minRet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgoMath_1_1Vector.html">goMath::Vector</a>&lt; <a class="el" href="group__types.html#ga02284d9088a729cca83dc808dd409e09">goSize_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxRet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="group__signal.html#gaf7d59cd91d4322a02939d5dc516b1b4e" title="Find min and max coordinates in sig where the value is below thresh. ">goSignalMinMaxCoord()</a>, but finds a light border. </p>
<p>Finds the borders when they have values higher than <code>thresh</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__signal.html#gaf7d59cd91d4322a02939d5dc516b1b4e" title="Find min and max coordinates in sig where the value is below thresh. ">goSignalMinMaxCoord()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>Signal. </td></tr>
    <tr><td class="paramname">thresh</td><td>Threshold. </td></tr>
    <tr><td class="paramname">minRet</td><td>On success, contains the min. coordinates of the region of interest without the light border. </td></tr>
    <tr><td class="paramname">maxRet</td><td>On success, contains the max. coordinates of the region of interest without the light border.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0302137b866e9f9d451c332d7bb4811a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool goFileIO::writeImage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgoSignal3DBase.html">goSignal3DBase</a>&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>signal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classgoFileIOException.html">goFileIOException</a>,</td>
        </tr>
        <tr>
          <td align="right"></td><td></td><td colspan="2"><a class="el" href="classgoTypeException.html">goTypeException</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an image file from a <a class="el" href="classgoSignal3DBase.html">goSignal3DBase&lt;void&gt;</a> object. </p>
<p>This function needs goLib to be compiled with support for the libIL image library. The supported image types depend on the types supported by libIL. At the time of this being written, those were</p><ul>
<li>.bmp</li>
<li>.dds</li>
<li>.jpg</li>
<li>.pcx</li>
<li>.png</li>
<li>.pnm</li>
<li>.raw</li>
<li>.sgi</li>
<li>.tga</li>
<li>.tif</li>
<li>.pal</li>
</ul>
<p>Note that these differ from the types supported for reading. The image type is selected by the filename's suffix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name for the image file. </td></tr>
    <tr><td class="paramname">signal</td><td><a class="el" href="classgoSignal3DBase.html">goSignal3DBase&lt;void&gt;</a> to be saved (currently only GO_FLOAT).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method only works when libGo was compiled with libIL support (<a href="http://openil.sourceforge.net">http://openil.sourceforge.net</a>). If not, it always returns false.</dd>
<dd>
This does not yet work for multichannel data.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000071">Todo:</a></b></dt><dd>This works only for float signals. Add other types. Add multichannel.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="videocapture_2videocapture_8cpp-example.html#a26">videocapture/videocapture.cpp</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
